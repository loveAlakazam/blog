<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>synchronized 와 ReentrantLock 은 어떤 차이점이 있을까? | EK Dev Blog</title>
<meta name=keywords content><meta name=description content="동시성제어를 테스트하는 것은 단위테스트에 적합할까? 통합테스트에 적합할까? JVM 내에서 동시성테스트를 하려고한다면, synchornized, ReentrantLock, JVM 내 큐(queue)를 사용하는 방법이 존재합니다. 그러나 동시성제어를 테스트할때 통합테스트에서 실행해야되는건지 아니면 유닛테스트에서 테스트를 해야될지 애매할겁니다.
단위테스트는 가장 작은 테스트인만큼 1개 메서드/함수 단위로 독립적인 기능을 빠르게 검증하기 위한 테스트입니다. 동시요청이 발생할 때 큐를 이용해서 순서를 제공해주거나 잠금(locking)연산을 수행하여 다른요청이 접근하지 못하도록 막거나, 큐를 이용해서 순서를 보장해줘야하는 역할까지 검증을 해야되기 때문에 단위테스트만으로는 어려울거같습니다.
즉, 동시성은 여러개의 스레드가 동시에 접근하거나 실행될 때 발생하는 문제를 검증해야하므로, 단일 스레드 환경에서 실행되는 단위테스트만으로는 동시적인 상황을 재현하기가 어렵습니다."><meta name=author content><link rel=canonical href=https://loveAlakazam.github.io/blog/docs/multi-thread-locks/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://loveAlakazam.github.io/blog/docs/multi-thread-locks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://loveAlakazam.github.io/blog/docs/multi-thread-locks/"><meta property="og:site_name" content="EK Dev Blog"><meta property="og:title" content="synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?"><meta property="og:description" content="동시성제어를 테스트하는 것은 단위테스트에 적합할까? 통합테스트에 적합할까? JVM 내에서 동시성테스트를 하려고한다면, synchornized, ReentrantLock, JVM 내 큐(queue)를 사용하는 방법이 존재합니다. 그러나 동시성제어를 테스트할때 통합테스트에서 실행해야되는건지 아니면 유닛테스트에서 테스트를 해야될지 애매할겁니다.
단위테스트는 가장 작은 테스트인만큼 1개 메서드/함수 단위로 독립적인 기능을 빠르게 검증하기 위한 테스트입니다. 동시요청이 발생할 때 큐를 이용해서 순서를 제공해주거나 잠금(locking)연산을 수행하여 다른요청이 접근하지 못하도록 막거나, 큐를 이용해서 순서를 보장해줘야하는 역할까지 검증을 해야되기 때문에 단위테스트만으로는 어려울거같습니다.
즉, 동시성은 여러개의 스레드가 동시에 접근하거나 실행될 때 발생하는 문제를 검증해야하므로, 단일 스레드 환경에서 실행되는 단위테스트만으로는 동시적인 상황을 재현하기가 어렵습니다."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-03-26T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?"><meta name=twitter:description content="동시성제어를 테스트하는 것은 단위테스트에 적합할까? 통합테스트에 적합할까? JVM 내에서 동시성테스트를 하려고한다면, synchornized, ReentrantLock, JVM 내 큐(queue)를 사용하는 방법이 존재합니다. 그러나 동시성제어를 테스트할때 통합테스트에서 실행해야되는건지 아니면 유닛테스트에서 테스트를 해야될지 애매할겁니다.
단위테스트는 가장 작은 테스트인만큼 1개 메서드/함수 단위로 독립적인 기능을 빠르게 검증하기 위한 테스트입니다. 동시요청이 발생할 때 큐를 이용해서 순서를 제공해주거나 잠금(locking)연산을 수행하여 다른요청이 접근하지 못하도록 막거나, 큐를 이용해서 순서를 보장해줘야하는 역할까지 검증을 해야되기 때문에 단위테스트만으로는 어려울거같습니다.
즉, 동시성은 여러개의 스레드가 동시에 접근하거나 실행될 때 발생하는 문제를 검증해야하므로, 단일 스레드 환경에서 실행되는 단위테스트만으로는 동시적인 상황을 재현하기가 어렵습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://loveAlakazam.github.io/blog/docs/"},{"@type":"ListItem","position":2,"name":"synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?","item":"https://loveAlakazam.github.io/blog/docs/multi-thread-locks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?","name":"synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?","description":"동시성제어를 테스트하는 것은 단위테스트에 적합할까? 통합테스트에 적합할까? JVM 내에서 동시성테스트를 하려고한다면, synchornized, ReentrantLock, JVM 내 큐(queue)를 사용하는 방법이 존재합니다. 그러나 동시성제어를 테스트할때 통합테스트에서 실행해야되는건지 아니면 유닛테스트에서 테스트를 해야될지 애매할겁니다.\n단위테스트는 가장 작은 테스트인만큼 1개 메서드/함수 단위로 독립적인 기능을 빠르게 검증하기 위한 테스트입니다. 동시요청이 발생할 때 큐를 이용해서 순서를 제공해주거나 잠금(locking)연산을 수행하여 다른요청이 접근하지 못하도록 막거나, 큐를 이용해서 순서를 보장해줘야하는 역할까지 검증을 해야되기 때문에 단위테스트만으로는 어려울거같습니다.\n즉, 동시성은 여러개의 스레드가 동시에 접근하거나 실행될 때 발생하는 문제를 검증해야하므로, 단일 스레드 환경에서 실행되는 단위테스트만으로는 동시적인 상황을 재현하기가 어렵습니다.","keywords":[],"articleBody":"동시성제어를 테스트하는 것은 단위테스트에 적합할까? 통합테스트에 적합할까? JVM 내에서 동시성테스트를 하려고한다면, synchornized, ReentrantLock, JVM 내 큐(queue)를 사용하는 방법이 존재합니다. 그러나 동시성제어를 테스트할때 통합테스트에서 실행해야되는건지 아니면 유닛테스트에서 테스트를 해야될지 애매할겁니다.\n단위테스트는 가장 작은 테스트인만큼 1개 메서드/함수 단위로 독립적인 기능을 빠르게 검증하기 위한 테스트입니다. 동시요청이 발생할 때 큐를 이용해서 순서를 제공해주거나 잠금(locking)연산을 수행하여 다른요청이 접근하지 못하도록 막거나, 큐를 이용해서 순서를 보장해줘야하는 역할까지 검증을 해야되기 때문에 단위테스트만으로는 어려울거같습니다.\n즉, 동시성은 여러개의 스레드가 동시에 접근하거나 실행될 때 발생하는 문제를 검증해야하므로, 단일 스레드 환경에서 실행되는 단위테스트만으로는 동시적인 상황을 재현하기가 어렵습니다. 따라서 동시성을 테스트하려면 통합테스트로 검증 해야됩니다.\n미션1: 동일한 사용자가 동시에 포인트 충전을 요청한 경우 [테스트 대상] 동일한 사용자가 동시에 포인트 1000원을 100번 충전 요청한 경우\n정상적으로 처리되야하며 총 10만원을 보유해야한다\n(공통) 통합테스트 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @SpringBootTest @AutoConfigureMockMvc @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD) public class ChargeConcurrencyTest { @Autowired private MockMvc mockMvc; @Autowired private PointService pointService; @Autowired private UserPointRepository userPointRepository; @Autowired private PointHistoryRepository pointHistoryRepository; @Autowired private ObjectMapper objectMapper; @Autowired private UserPointLockManager userPointLockManager; @BeforeEach void setUp() { // UserPoint 의 초기 포인트값을 0 으로한다. userPointRepository.save(1L, 0L); } @Test void 동시에_100번_충전요청을_요청했을때_정상적으로_처리되며_충전요청후_보유잔액이_100000원이면_성공이다() throws Exception { // given long id = 1L; int threadCount = 100; long chargeAmount = 1000L; ExecutorService executor = Executors.newFixedThreadPool(10); // 스레드풀 10개 CountDownLatch latch = new CountDownLatch(threadCount); // 요청가능한 스레드개수 ChargeRequestBody requestBody = new ChargeRequestBody(chargeAmount); String json = objectMapper.writeValueAsString(requestBody); // when for(int i = 0 ; i \u003c threadCount ; i++) { executor.submit(()-\u003e { try { // 충전 API 호출 mockMvc.perform(patch(\"/point/\"+id+\"/charge\") .contentType(MediaType.APPLICATION_JSON) .content(json)); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(e); } finally { latch.countDown(); // 요청가능 스레드 개수 감소 } }); } latch.await(); // 다 끝날 때까지 대기 Thread.sleep(1000); // 1초 정도 대기후 최종 포인트 확인 // then long expectedPoint = chargeAmount * threadCount; long finalPoint = userPointRepository.findById(id).point(); assertEquals(expectedPoint, finalPoint, \"충전후 포인트값이 예상값(\"+expectedPoint+\")과 실제값(\"+finalPoint+\")이 서로다릅니다.\"); } } synchronized synchronized는 하나의 스레드만 임계영역(critical section)에 접근하도록 보장하는 키워드로, 공유자원에 대한 동시접근을 차단하여 Race Condition을 방지합니다.\nJava에서 제공하는 synchronized 키워드는 모니터락(MonitorLock)을 이용하여 동기화를 지원합니다.\nMonitor은 OS가 아닌 프로그래밍 수준에서 제공하는 동기화 메커니즘입니다. Java 모든 객체(인스턴스)는 내부적으로 고유한 모니터를 가지며, 이를 획득하고 해제하며 동기화 작업을 수행합니다. 즉, 모니터와 락은 서로 상호보완적인 관계로 대체하거나 비교할 수 있는 개념이 아닙니다.\n스레드 상태\n스레드 상태 설명 NEW 스레드가 새로 생성되었지만 아직 시작하지 않은 상태 RUNNABLE 동기화된 락이 풀리기를 기다리는 상태. synchronized 사용시 발생 BLOCKED 동기화 락이 풀리기를 기다리는 상태 WAITING 다른 스레드의 특정 작업이 완료되기를 무한정 기다리는 상태. wait(), join() 호출 TIMEOUT_WAITING 특정시간동안 대기하는 상태. sleep(), wait(timeout), join(timeout) 호출 TERMINATED 스레드의 실행이 완료된 상태 특징\n락을 획득하지 못한 스레드는 RUNNABLE 상태에서 BLOCKED 상태로 전환됩니다. 락을 획득할 때까지 대기하며, 이동안 CPU 실행 스케줄링에서 제외됩니다.\n여러 스레드가 대기중일 경우, 락 획득 순서는 보장되지 않습니다.\nsynchronized 블록안에서 변수의 메모리 가시성 문제가 자동으로 해결되므로 별도의 volatile 선언이 필요하지 않습니다.\nvolatile 키워드: 해당변수는 모두 읽기와 쓰기 작업이 CPU 캐시가 아닌 메인메모리에서 이뤄지는 것을 의미한다. 단점\nBLOCKED 상태의 스레드는 락이 풀릴때까지 무한 대기를 하며 synchronized는 인터럽트, 타임아웃을 지원하지 않습니다.\n다만 wait()을 통해 Blocked 상태인 스레드를 WAITING 으로 변경하고, 해당 스레드를 인터럽트 시킬 수 있습니다.\n공정성문제: 락이 돌아왔을 때 BLOCKED 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할지 알 수 없습니다.\n충전 서비스 내부로직에 synchronized 예약어를 추가하여 임계구역 블록 지정하기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // PointServiceImpl @RequiredArgsConstructor public class PointServiceImpl implements PointService { private final UserPointRepository userPointRepository; private final PointHistoryRepository pointHistoryRepository; private final UserPointLockManager userPointLockManager; private static final Logger log = LoggerFactory.getLogger(PointServiceImpl.class); ... @Override public synchronized ChargeResponse charge(ChargeRequest request) { long id = request.id(); long amount = request.amount(); // 로그기록 log.info(\"::: 🔒 Lock acquired for userId: {}, thread: {}\", id, Thread.currentThread().getName());UserPoint myPoint = this.userPointRepository.findById(id); // 포인트 충전 long pointAfterCharge = myPoint.charge(amount); // 포인트내역에 '충전' 기록 this.pointHistoryRepository.insert(id, amount, TransactionType.CHARGE); // 보유포인트 정보 수정 UserPoint result = this.userPointRepository.save(id, pointAfterCharge); log.info(\"::: thread {} 작업완료:: 유저 id {}의 충전후 보유 포인트: {}\",Thread.currentThread().getName(), id, result.point() ); return ChargeResponse.from(result); } } 실행결과: 성공\nReentrantLock ReentrantLock은 동일한 쓰레드가 여러번 락을 획득할 수 있는 재진입이 가능한 락으로 synchronized 보다 더 정밀한 락제어와 락 확인 상태, 타임아웃, 인터럽트 처리등이 가능한 클래스입니다. 또한 ReentrantLock은 실시간 제어, deadlock 회피, 락 상태 진단 등 고급제어가 필요할 때 적합합니다.\n유저포인트 ID(id) 마다 락을 관리 - ConcurrentHashMap 으로 분리된 락들을 관리\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // UserPointLockManager @Component public class UserPointLockManager { // 사용자별 분리된 락을 관리하는 맵 // 1. 사용자 ID(id) 마다 하나의 고유한 락(Object)를 저장하는 맵 // 2. synchronized에 넘길 락을 하나만 쓰면 전역락(exclusive lock)이 되므로 사용자별로 분리된 락객체를 관리 private final ConcurrentHashMap\u003cLong, ReentrantLock\u003e locks = new ConcurrentHashMap\u003c\u003e(); public ReentrantLock getLock(long id) { // locks.computeIfAbsent(id, key -\u003e new Object()); // 1. 사용자 ID(id)에 해당하는 락객체가 이미 있으면 그 객체를 반환하고, 없다면 새로운 락을 넣는다. // 2. 사용자 ID(id)별 하나의 고유한 락을 필요할 때만 만들고 중복으로 만들지않도록 보장한다. return locks.computeIfAbsent(id, key -\u003e new ReentrantLock()); } } 충전 서비스 내부로직에 try블록을 임계구역 블록 지정하고 임계구역 입구에는 lock.lock()은 잠금상태인지(이미 요청작업을 수행하고있는 중인지) 아닌지를 확인하고, 잠겨있다면 끝날때까지 기다려야합니다. 반대로 열려있는 상태라면 임계영역에 진입하여 잠궈야합니다. 작업결과에 상관없이 요청작업 수행이 완료되면 lock.unlock()으로 잠금을 해제합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // PointServiceImpl @Service @RequiredArgsConstructor public class PointServiceImpl implements PointService { private final UserPointRepository userPointRepository; private final PointHistoryRepository pointHistoryRepository; private static final Logger log = LoggerFactory.getLogger(PointServiceImpl.class); private final UserPointLockManager userPointLockManager; @Override public ChargeResponse charge(ChargeRequest request) { long id = request.id(); long amount = request.amount(); // 락 획득하여 다른요청이 들어오지 못하도록 임계구역을 잠금 ReentrantLock lock = userPointLockManager.getLock(id); lock.lock(); try { // try 블록안은 임계구역 이므로, 하나의 요청이 작업을 수행 log.info(\"::: 🔒 Lock acquired for userId: {}, thread: {}\", id, Thread.currentThread().getName()); // 공유자원 정의 UserPoint userPoint = this.userPointRepository.findById(id); long myPoint = userPoint.point(); this.pointHistoryRepository.insert(id, amount, TransactionType.CHARGE); // 포인트내역에 '충전' 기록 UserPoint result = this.userPointRepository.save(id, myPoint + amount); // 포인트 충전 return ChargeResponse.from(result); } finally { lock.unlock(); // 락을 반환하여 임계구역을 잠금해제 } } } 실행결과: 성공\nsynchronized 와 ReentrantLock 은 어떤 차이점이 있을까? synchronized는 메서드블록으로 락을 획득하면 블록내에서 다른 스레드가 접근하는 것을 막습니다. 하지만 락의 해제하는 코드가 존재하지 않습니다. 반면 ReentrantLock은 synchronized 보다 더 많은 인터페이스들을 제공해줍니다. 대표적으로 잠금해제(unlock)을 제공해주어 잠금을 해제할 시기를 명시적으로 나타낼 수 있습니다.\n잠금관리의 유연성: 명시적으로 잠금획득(lock())/ 잠금해제(unlock()) 을 제공해줍니다. 잠금을 시도하는 기능: tryLock() 스레드가 무기한 대기하지 않고 잠금을 획득할 수 있도록 합니다. 인터럽트 가능한 잠금획득: lockInterruptibly() 스레드가 중단될 수 있는 상황에서 잠금을 획득할 수 있도록 합니다. 공정성 정책 옵션: ReentrantLock 의 공정성 정책을 지정할 수 있습니다. 공정한 잠금은 오래 기다리는 스레드의 우선순위를 정하여 스레드의 기아를 피하는데 사용됩니다. synchronized 메커니즘은 공정성을 보장하지 않습니다. 시간 잠금 대기: tryLock(long timeout,TimeUnit unit) 스레드가 지정된 기간동안 잠금을 획득하려고 시도할 수 있습니다. 스레드가 잠금을 기다리는 시간을 제한해야하는 시나리오에서 사용됩니다. 미션내용: 동일한 사용자가 아닌 여러사용자이 동시에 충전을 했을 때, 둘의 차이는 어떻게 될까?\n두개의 락은 모두 다 비관적락이며, 스레드가 이미 작업을 수행중이라면, 다른 스레드들은 앞의 스레드의 작업이 끝날때까지 기다려야합니다. 해당 미션내용을 진행했을 때, 두개의 락이 진행하는데 걸리는 시간과 실행결과를 측정해보고자합니다.\n미션2: 서로다른 사용자가 동시에 포인트 충전을 요청한 경우 [테스트 대상] 서로다른 사용자 10명이 동시에 포인트 1000원을 10번 충전했을 경우\n정상적으로 처리되야하며 각 유저는 총 만원을 보유해야한다.\n(공통) 통합테스트 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Test void 서로_다른유저_10명이_동시에_1000원_충전을_요청했을때_정상적으로_합산에_성공한다() throws Exception { // given int numberOfUsers = 10; // 인원수 int requestPerUser = 10; // 한사람당 요청개수 // 포인트 초기화 for(long id = 1L; id \u003c numberOfUsers ; id++) { userPointRepository.save(id, 0L); } ExecutorService executor = Executors.newFixedThreadPool(5); // 스레드풀: 5개. (요청 5개 동시에 실행가능) CountDownLatch latch = new CountDownLatch(numberOfUsers * requestPerUser); // 10 * 10 long chargeAmount = 1000L; // when for(long id = 1L; id \u003c= numberOfUsers; id++) { ChargeRequest request = new ChargeRequest(id, chargeAmount); // 유저 1명당 10번을 요청한다. for(int i = 0 ; i \u003c requestPerUser; i++) { long uid = id; executor.submit(() -\u003e { try { if(uid == 1L) sleep(1000); pointService.charge(request); } catch(Exception e) { e.printStackTrace(); throw new RuntimeException(e); } finally { latch.countDown(); } }); } } latch.await(); sleep(1000); // then log.info(\"::: 테스트 종료후 유저별 보유포인트 조회 :::\"); for(long id = 1L; id \u003c= numberOfUsers; id++){ long actualPoint = userPointRepository.findById(id).point(); log.info(\"유저 ID {} 의 보유포인트: {}\", id, actualPoint); } for(long id =1L; id \u003c= numberOfUsers; id++) { long actualPoint = userPointRepository.findById(id).point(); assertEquals(requestPerUser * chargeAmount, actualPoint,\"UserPoint id \"+id+ \"인 회원의 포인트는 예상금액과 다릅니다: \"+ actualPoint + \"원\" ); } } 특정스레드를 슬립을 시키지 않은채 동시성제어 테스트를 실행시킨 결과 synchronized : 성공 (44s)\nReentrantLock : 성공 (31s)\nReentrantLock 이 상대적으로 실행속도가 빠른편입니다. 공정성을 제공하고 해시맵으로 락을 구분하기 때문입니다. 그에반면 락의 구분이 없습니다. synchronized는 synchronized 키워드로 부여된 charge함수블록이 임계구역임을 나타냅니다.\n만일 특정 유저에게만 1초의 Thread.sleep 을 했을 경우 synchronized와 ReentrantLock 간의 실행시간차이가 점점 더 커집니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for(long id = 1L; id \u003c= numberOfUsers; id++) { ChargeRequest request = new ChargeRequest(id, chargeAmount); // 유저 1명당 10번을 요청한다. for(int i = 0 ; i \u003c requestPerUser; i++) { long uid = id; executor.submit(() -\u003e { try { if(uid == 1L) sleep(1000); // id=1 번인 유저는 1초 대기 pointService.charge(request); } catch(Exception e) { e.printStackTrace(); throw new RuntimeException(e); } finally { latch.countDown(); } }); } } synchronized : 성공 (47s)\nReentrantLock : 성공 (33s)\n결론 현재 synchronized, ReentrantLock 등 JVM내에서만 활용되는 락이며 하나의 서버에서는 가능합니다.\nsynchronized 은 임계구역을 블록으로 지정하여 나타내지만 단순하게 동시성제어를 처리하는데 좋습니다.\nsynchronized 는 간단하게 한개의 스레드에만 접근하도록 설정해줍니다. 공유데이터에 하나의 스레드만이 접근이 가능하다는 조건이 하나의 프로세스에만 보장됩니다. 이러한 특징때문에 scale-out 하게되면 서버가 여러대일때 동시성을 보장하지 않습니다.\nReentrantLock 은 임계구역을 진입하기전에는 lock를 임계구역을 빠져나오면 unlock 으로 명시하여 synchronized 보다는 정교하게 나타냅니다.\n동시성제어와 관련된 테스팅은 작성할 때는 단위테스트보다 통합테스트가 적합합니다.\n선입선출 자료구조인 큐(queue)를 이용해서 동시성제어 를 해결할 수 있습니다. 하지만 Lock다르게 여러 요청이 한번에 들어와도 각 요청을 큐에넣고 순차적으로 처리하는방식입니다. 순서가 있기 때문에 동시성을 제거시켜서 해결하는 방법입니다.\n참고\nJava Synchronized vs ReentrantLock: In-Depth Comparison for Optimal Locking Choice Java의 동기화 기법 - synchronized \u0026 ReentrantLock 에 대해 스프링에서의 동시성 처리 ","wordCount":"1755","inLanguage":"en","datePublished":"2025-03-26T00:00:00Z","dateModified":"2025-03-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://loveAlakazam.github.io/blog/docs/multi-thread-locks/"},"publisher":{"@type":"Organization","name":"EK Dev Blog","logo":{"@type":"ImageObject","url":"https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loveAlakazam.github.io/blog/ accesskey=h title="EK Dev Blog (Alt + H)"><img src=https://loveAlakazam.github.io/apple-touch-icon.png alt aria-label=logo height=35>EK Dev Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eunkangchoi.github.io/resume/ title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loveAlakazam.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://loveAlakazam.github.io/blog/docs/>Docs</a></div><h1 class="post-title entry-hint-parent">synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?</h1><div class=post-meta><span title='2025-03-26 00:00:00 +0000 UTC'>March 26, 2025</span></div></header><div class=post-content><h2 id=동시성제어를-테스트하는-것은-단위테스트에-적합할까-통합테스트에-적합할까>동시성제어를 테스트하는 것은 단위테스트에 적합할까? 통합테스트에 적합할까?<a hidden class=anchor aria-hidden=true href=#동시성제어를-테스트하는-것은-단위테스트에-적합할까-통합테스트에-적합할까>#</a></h2><p>JVM 내에서 동시성테스트를 하려고한다면, synchornized, ReentrantLock, JVM 내 큐(queue)를 사용하는 방법이 존재합니다. 그러나 동시성제어를 테스트할때 통합테스트에서 실행해야되는건지 아니면 유닛테스트에서 테스트를 해야될지 애매할겁니다.</p><p>단위테스트는 가장 작은 테스트인만큼 1개 메서드/함수 단위로 독립적인 기능을 빠르게 검증하기 위한 테스트입니다.
동시요청이 발생할 때 큐를 이용해서 순서를 제공해주거나 잠금(locking)연산을 수행하여 다른요청이 접근하지 못하도록 막거나, 큐를 이용해서 순서를 보장해줘야하는 역할까지 검증을 해야되기 때문에 단위테스트만으로는 어려울거같습니다.</p><p>즉, 동시성은 여러개의 스레드가 동시에 접근하거나 실행될 때 발생하는 문제를 검증해야하므로, 단일 스레드 환경에서 실행되는 단위테스트만으로는 동시적인 상황을 재현하기가 어렵습니다. <strong>따라서 동시성을 테스트하려면 통합테스트로 검증</strong> 해야됩니다.</p><hr><h2 id=미션1-동일한-사용자가-동시에-포인트-충전을-요청한-경우>미션1: 동일한 사용자가 동시에 포인트 충전을 요청한 경우<a hidden class=anchor aria-hidden=true href=#미션1-동일한-사용자가-동시에-포인트-충전을-요청한-경우>#</a></h2><blockquote><p>[테스트 대상]
동일한 사용자가 동시에 포인트 1000원을 100번 충전 요청한 경우</p><p>정상적으로 처리되야하며 총 10만원을 보유해야한다</p></blockquote><h3 id=공통-통합테스트-코드>(공통) 통합테스트 코드<a hidden class=anchor aria-hidden=true href=#공통-통합테스트-코드>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span><span class=lnt id=hl-0-42><a class=lnlinks href=#hl-0-42>42</a>
</span><span class=lnt id=hl-0-43><a class=lnlinks href=#hl-0-43>43</a>
</span><span class=lnt id=hl-0-44><a class=lnlinks href=#hl-0-44>44</a>
</span><span class=lnt id=hl-0-45><a class=lnlinks href=#hl-0-45>45</a>
</span><span class=lnt id=hl-0-46><a class=lnlinks href=#hl-0-46>46</a>
</span><span class=lnt id=hl-0-47><a class=lnlinks href=#hl-0-47>47</a>
</span><span class=lnt id=hl-0-48><a class=lnlinks href=#hl-0-48>48</a>
</span><span class=lnt id=hl-0-49><a class=lnlinks href=#hl-0-49>49</a>
</span><span class=lnt id=hl-0-50><a class=lnlinks href=#hl-0-50>50</a>
</span><span class=lnt id=hl-0-51><a class=lnlinks href=#hl-0-51>51</a>
</span><span class=lnt id=hl-0-52><a class=lnlinks href=#hl-0-52>52</a>
</span><span class=lnt id=hl-0-53><a class=lnlinks href=#hl-0-53>53</a>
</span><span class=lnt id=hl-0-54><a class=lnlinks href=#hl-0-54>54</a>
</span><span class=lnt id=hl-0-55><a class=lnlinks href=#hl-0-55>55</a>
</span><span class=lnt id=hl-0-56><a class=lnlinks href=#hl-0-56>56</a>
</span><span class=lnt id=hl-0-57><a class=lnlinks href=#hl-0-57>57</a>
</span><span class=lnt id=hl-0-58><a class=lnlinks href=#hl-0-58>58</a>
</span><span class=lnt id=hl-0-59><a class=lnlinks href=#hl-0-59>59</a>
</span><span class=lnt id=hl-0-60><a class=lnlinks href=#hl-0-60>60</a>
</span><span class=lnt id=hl-0-61><a class=lnlinks href=#hl-0-61>61</a>
</span><span class=lnt id=hl-0-62><a class=lnlinks href=#hl-0-62>62</a>
</span><span class=lnt id=hl-0-63><a class=lnlinks href=#hl-0-63>63</a>
</span><span class=lnt id=hl-0-64><a class=lnlinks href=#hl-0-64>64</a>
</span><span class=lnt id=hl-0-65><a class=lnlinks href=#hl-0-65>65</a>
</span><span class=lnt id=hl-0-66><a class=lnlinks href=#hl-0-66>66</a>
</span><span class=lnt id=hl-0-67><a class=lnlinks href=#hl-0-67>67</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootTest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@AutoConfigureMockMvc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@DirtiesContext</span><span class=p>(</span><span class=n>classMode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>DirtiesContext</span><span class=p>.</span><span class=na>ClassMode</span><span class=p>.</span><span class=na>AFTER_EACH_TEST_METHOD</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ChargeConcurrencyTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>MockMvc</span><span class=w> </span><span class=n>mockMvc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>PointService</span><span class=w> </span><span class=n>pointService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>UserPointRepository</span><span class=w> </span><span class=n>userPointRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>PointHistoryRepository</span><span class=w> </span><span class=n>pointHistoryRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>ObjectMapper</span><span class=w> </span><span class=n>objectMapper</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>UserPointLockManager</span><span class=w> </span><span class=n>userPointLockManager</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@BeforeEach</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setUp</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// UserPoint 의 초기 포인트값을 0 으로한다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>userPointRepository</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>1L</span><span class=p>,</span><span class=w> </span><span class=n>0L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>동시에_100번_충전요청을_요청했을때_정상적으로_처리되며_충전요청후_보유잔액이_100000원이면_성공이다</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// given</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1L</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>threadCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>100</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>chargeAmount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1000L</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ExecutorService</span><span class=w> </span><span class=n>executor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Executors</span><span class=p>.</span><span class=na>newFixedThreadPool</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w> </span><span class=c1>// 스레드풀 10개</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>CountDownLatch</span><span class=w> </span><span class=n>latch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CountDownLatch</span><span class=p>(</span><span class=n>threadCount</span><span class=p>);</span><span class=w> </span><span class=c1>// 요청가능한 스레드개수</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ChargeRequestBody</span><span class=w> </span><span class=n>requestBody</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ChargeRequestBody</span><span class=p>(</span><span class=n>chargeAmount</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>String</span><span class=w> </span><span class=n>json</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>objectMapper</span><span class=p>.</span><span class=na>writeValueAsString</span><span class=p>(</span><span class=n>requestBody</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// when</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>threadCount</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// 충전 API 호출</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>mockMvc</span><span class=p>.</span><span class=na>perform</span><span class=p>(</span><span class=n>patch</span><span class=p>(</span><span class=s>&#34;/point/&#34;</span><span class=o>+</span><span class=n>id</span><span class=o>+</span><span class=s>&#34;/charge&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=na>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=na>APPLICATION_JSON</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=na>content</span><span class=p>(</span><span class=n>json</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>latch</span><span class=p>.</span><span class=na>countDown</span><span class=p>();</span><span class=w> </span><span class=c1>// 요청가능 스레드 개수 감소</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>latch</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 다 끝날 때까지 대기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// 1초 정도 대기후 최종 포인트 확인</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>expectedPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>chargeAmount</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>threadCount</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>finalPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userPointRepository</span><span class=p>.</span><span class=na>findById</span><span class=p>(</span><span class=n>id</span><span class=p>).</span><span class=na>point</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>assertEquals</span><span class=p>(</span><span class=n>expectedPoint</span><span class=p>,</span><span class=w> </span><span class=n>finalPoint</span><span class=p>,</span><span class=w> </span><span class=s>&#34;충전후 포인트값이 예상값(&#34;</span><span class=o>+</span><span class=n>expectedPoint</span><span class=o>+</span><span class=s>&#34;)과 실제값(&#34;</span><span class=o>+</span><span class=n>finalPoint</span><span class=o>+</span><span class=s>&#34;)이 서로다릅니다.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=synchronized>synchronized<a hidden class=anchor aria-hidden=true href=#synchronized>#</a></h3><ul><li><p><code>synchronized</code>는 하나의 스레드만 임계영역(critical section)에 접근하도록 보장하는 키워드로, 공유자원에 대한 동시접근을 차단하여 Race Condition을 방지합니다.</p></li><li><p>Java에서 제공하는 synchronized 키워드는 모니터락(MonitorLock)을 이용하여 동기화를 지원합니다.</p></li><li><p>Monitor은 OS가 아닌 프로그래밍 수준에서 제공하는 동기화 메커니즘입니다. Java 모든 객체(인스턴스)는 내부적으로 고유한 모니터를 가지며, 이를 획득하고 해제하며 동기화 작업을 수행합니다. 즉, 모니터와 락은 서로 상호보완적인 관계로 대체하거나 비교할 수 있는 개념이 아닙니다.</p></li><li><p>스레드 상태</p></li></ul><table><thead><tr><th style=text-align:left>스레드 상태</th><th>설명</th></tr></thead><tbody><tr><td style=text-align:left>NEW</td><td>스레드가 새로 생성되었지만 아직 시작하지 않은 상태</td></tr><tr><td style=text-align:left>RUNNABLE</td><td>동기화된 락이 풀리기를 기다리는 상태. synchronized 사용시 발생</td></tr><tr><td style=text-align:left>BLOCKED</td><td>동기화 락이 풀리기를 기다리는 상태</td></tr><tr><td style=text-align:left>WAITING</td><td>다른 스레드의 특정 작업이 완료되기를 무한정 기다리는 상태. wait(), join() 호출</td></tr><tr><td style=text-align:left>TIMEOUT_WAITING</td><td>특정시간동안 대기하는 상태. sleep(), wait(timeout), join(timeout) 호출</td></tr><tr><td style=text-align:left>TERMINATED</td><td>스레드의 실행이 완료된 상태</td></tr></tbody></table><blockquote><p>특징</p></blockquote><ul><li><p>락을 획득하지 못한 스레드는 RUNNABLE 상태에서 BLOCKED 상태로 전환됩니다. 락을 획득할 때까지 대기하며, 이동안 CPU 실행 스케줄링에서 제외됩니다.</p></li><li><p>여러 스레드가 대기중일 경우, 락 획득 순서는 보장되지 않습니다.</p></li><li><p>synchronized 블록안에서 변수의 메모리 가시성 문제가 자동으로 해결되므로 별도의 volatile 선언이 필요하지 않습니다.</p><ul><li>volatile 키워드: 해당변수는 모두 읽기와 쓰기 작업이 CPU 캐시가 아닌 <em>메인메모리에서</em> 이뤄지는 것을 의미한다.</li></ul></li></ul><blockquote><p>단점</p></blockquote><ul><li><p>BLOCKED 상태의 스레드는 락이 풀릴때까지 무한 대기를 하며 synchronized는 인터럽트, 타임아웃을 지원하지 않습니다.</p></li><li><p>다만 wait()을 통해 Blocked 상태인 스레드를 WAITING 으로 변경하고, 해당 스레드를 인터럽트 시킬 수 있습니다.</p></li><li><p>공정성문제: 락이 돌아왔을 때 BLOCKED 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할지 알 수 없습니다.</p></li></ul><blockquote><p>충전 서비스 내부로직에 synchronized 예약어를 추가하여 임계구역 블록 지정하기</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// PointServiceImpl</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RequiredArgsConstructor</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PointServiceImpl</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>PointService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>UserPointRepository</span><span class=w> </span><span class=n>userPointRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>PointHistoryRepository</span><span class=w> </span><span class=n>pointHistoryRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>UserPointLockManager</span><span class=w> </span><span class=n>userPointLockManager</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=n>log</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LoggerFactory</span><span class=p>.</span><span class=na>getLogger</span><span class=p>(</span><span class=n>PointServiceImpl</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=kd>synchronized</span><span class=w> </span><span class=n>ChargeResponse</span><span class=w> </span><span class=nf>charge</span><span class=p>(</span><span class=n>ChargeRequest</span><span class=w> </span><span class=n>request</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>request</span><span class=p>.</span><span class=na>id</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>amount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>request</span><span class=p>.</span><span class=na>amount</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 로그기록</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;::: 🔒 Lock acquired for userId: {}, thread: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>());</span><span class=n>UserPoint</span><span class=w> </span><span class=n>myPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>userPointRepository</span><span class=p>.</span><span class=na>findById</span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 포인트 충전</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>long</span><span class=w> </span><span class=n>pointAfterCharge</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>myPoint</span><span class=p>.</span><span class=na>charge</span><span class=p>(</span><span class=n>amount</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 포인트내역에 &#39;충전&#39; 기록</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>this</span><span class=p>.</span><span class=na>pointHistoryRepository</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>amount</span><span class=p>,</span><span class=w> </span><span class=n>TransactionType</span><span class=p>.</span><span class=na>CHARGE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 보유포인트 정보 수정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>UserPoint</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>userPointRepository</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>pointAfterCharge</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;::: thread {} 작업완료:: 유저 id {}의 충전후 보유 포인트: {}&#34;</span><span class=p>,</span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>(),</span><span class=w>  </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>.</span><span class=na>point</span><span class=p>()</span><span class=w> </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=n>ChargeResponse</span><span class=p>.</span><span class=na>from</span><span class=p>(</span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>실행결과: 성공</p></blockquote><h3 id=reentrantlock>ReentrantLock<a hidden class=anchor aria-hidden=true href=#reentrantlock>#</a></h3><p><code>ReentrantLock</code>은 동일한 쓰레드가 여러번 락을 획득할 수 있는 재진입이 가능한 락으로 <code>synchronized</code> 보다 더 정밀한 락제어와 락 확인 상태, 타임아웃, 인터럽트 처리등이 가능한 클래스입니다. 또한 <code>ReentrantLock</code>은 실시간 제어, deadlock 회피, 락 상태 진단 등 고급제어가 필요할 때 적합합니다.</p><blockquote><p>유저포인트 ID(id) 마다 락을 관리 - ConcurrentHashMap 으로 분리된 락들을 관리</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// UserPointLockManager</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserPointLockManager</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 사용자별 분리된 락을 관리하는 맵</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 사용자 ID(id) 마다 하나의 고유한 락(Object)를 저장하는 맵</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 2. synchronized에 넘길 락을 하나만 쓰면 전역락(exclusive lock)이 되므로 사용자별로 분리된 락객체를 관리</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ConcurrentHashMap</span><span class=o>&lt;</span><span class=n>Long</span><span class=p>,</span><span class=w> </span><span class=n>ReentrantLock</span><span class=o>&gt;</span><span class=w> </span><span class=n>locks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ConcurrentHashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=nf>getLock</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// locks.computeIfAbsent(id, key -&gt; new Object());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 사용자 ID(id)에 해당하는 락객체가 이미 있으면 그 객체를 반환하고, 없다면 새로운 락을 넣는다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 2. 사용자 ID(id)별 하나의 고유한 락을 필요할 때만 만들고 중복으로 만들지않도록 보장한다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>locks</span><span class=p>.</span><span class=na>computeIfAbsent</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>충전 서비스 내부로직에 try블록을 임계구역 블록 지정하고
임계구역 입구에는 <code>lock.lock()</code>은 잠금상태인지(이미 요청작업을 수행하고있는 중인지) 아닌지를 확인하고, 잠겨있다면 끝날때까지 기다려야합니다. 반대로 열려있는 상태라면 임계영역에 진입하여 잠궈야합니다.
작업결과에 상관없이 요청작업 수행이 완료되면 <code>lock.unlock()</code>으로 잠금을 해제합니다.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// PointServiceImpl</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RequiredArgsConstructor</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PointServiceImpl</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>PointService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>UserPointRepository</span><span class=w> </span><span class=n>userPointRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>PointHistoryRepository</span><span class=w> </span><span class=n>pointHistoryRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=n>log</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LoggerFactory</span><span class=p>.</span><span class=na>getLogger</span><span class=p>(</span><span class=n>PointServiceImpl</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>UserPointLockManager</span><span class=w> </span><span class=n>userPointLockManager</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=n>ChargeResponse</span><span class=w> </span><span class=nf>charge</span><span class=p>(</span><span class=n>ChargeRequest</span><span class=w> </span><span class=n>request</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>request</span><span class=p>.</span><span class=na>id</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>amount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>request</span><span class=p>.</span><span class=na>amount</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 락 획득하여 다른요청이 들어오지 못하도록 임계구역을 잠금</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ReentrantLock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userPointLockManager</span><span class=p>.</span><span class=na>getLock</span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// try 블록안은 임계구역 이므로, 하나의 요청이 작업을 수행</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;::: 🔒 Lock acquired for userId: {}, thread: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// 공유자원 정의</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>UserPoint</span><span class=w> </span><span class=n>userPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>userPointRepository</span><span class=p>.</span><span class=na>findById</span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>long</span><span class=w> </span><span class=n>myPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userPoint</span><span class=p>.</span><span class=na>point</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=na>pointHistoryRepository</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>amount</span><span class=p>,</span><span class=w> </span><span class=n>TransactionType</span><span class=p>.</span><span class=na>CHARGE</span><span class=p>);</span><span class=w> </span><span class=c1>// 포인트내역에 &#39;충전&#39; 기록</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>UserPoint</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>userPointRepository</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>myPoint</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>amount</span><span class=p>);</span><span class=w> </span><span class=c1>// 포인트 충전</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=n>ChargeResponse</span><span class=p>.</span><span class=na>from</span><span class=p>(</span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w> </span><span class=c1>// 락을 반환하여 임계구역을 잠금해제</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>실행결과: 성공</p></blockquote><hr><h2 id=synchronized-와-reentrantlock-은-어떤-차이점이-있을까>synchronized 와 ReentrantLock 은 어떤 차이점이 있을까?<a hidden class=anchor aria-hidden=true href=#synchronized-와-reentrantlock-은-어떤-차이점이-있을까>#</a></h2><ul><li>synchronized는 메서드블록으로 락을 획득하면 블록내에서 다른 스레드가 접근하는 것을 막습니다. 하지만 락의 해제하는 코드가 존재하지 않습니다.</li></ul><p>반면 ReentrantLock은 synchronized 보다 더 많은 인터페이스들을 제공해줍니다. 대표적으로 잠금해제(unlock)을 제공해주어 잠금을 해제할 시기를 명시적으로 나타낼 수 있습니다.</p><ul><li>잠금관리의 유연성: 명시적으로 잠금획득(lock())/ 잠금해제(unlock()) 을 제공해줍니다.</li><li>잠금을 시도하는 기능: <code>tryLock()</code> 스레드가 무기한 대기하지 않고 잠금을 획득할 수 있도록 합니다.</li><li>인터럽트 가능한 잠금획득: <code>lockInterruptibly()</code> 스레드가 중단될 수 있는 상황에서 잠금을 획득할 수 있도록 합니다.</li><li>공정성 정책 옵션: ReentrantLock 의 공정성 정책을 지정할 수 있습니다. 공정한 잠금은 오래 기다리는 스레드의 우선순위를 정하여 스레드의 기아를 피하는데 사용됩니다. synchronized 메커니즘은 공정성을 보장하지 않습니다.</li><li>시간 잠금 대기: <code>tryLock(long timeout,TimeUnit unit)</code> 스레드가 지정된 기간동안 잠금을 획득하려고 시도할 수 있습니다. 스레드가 잠금을 기다리는 시간을 제한해야하는 시나리오에서 사용됩니다.</li></ul><blockquote><p>미션내용: 동일한 사용자가 아닌 여러사용자이 동시에 충전을 했을 때, 둘의 차이는 어떻게 될까?</p></blockquote><p>두개의 락은 모두 다 비관적락이며, 스레드가 이미 작업을 수행중이라면, 다른 스레드들은 앞의 스레드의 작업이 끝날때까지 기다려야합니다. 해당 미션내용을 진행했을 때, 두개의 락이 진행하는데 걸리는 시간과 실행결과를 측정해보고자합니다.</p><hr><h2 id=미션2-서로다른-사용자가-동시에-포인트-충전을-요청한-경우>미션2: 서로다른 사용자가 동시에 포인트 충전을 요청한 경우<a hidden class=anchor aria-hidden=true href=#미션2-서로다른-사용자가-동시에-포인트-충전을-요청한-경우>#</a></h2><blockquote><p>[테스트 대상]
서로다른 사용자 10명이 동시에 포인트 1000원을 10번 충전했을 경우</p><p>정상적으로 처리되야하며 각 유저는 총 만원을 보유해야한다.</p></blockquote><h3 id=공통-통합테스트-코드-1>(공통) 통합테스트 코드<a hidden class=anchor aria-hidden=true href=#공통-통합테스트-코드-1>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span><span class=lnt id=hl-4-47><a class=lnlinks href=#hl-4-47>47</a>
</span><span class=lnt id=hl-4-48><a class=lnlinks href=#hl-4-48>48</a>
</span><span class=lnt id=hl-4-49><a class=lnlinks href=#hl-4-49>49</a>
</span><span class=lnt id=hl-4-50><a class=lnlinks href=#hl-4-50>50</a>
</span><span class=lnt id=hl-4-51><a class=lnlinks href=#hl-4-51>51</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w> </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>서로_다른유저_10명이_동시에_1000원_충전을_요청했을때_정상적으로_합산에_성공한다</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// given</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>numberOfUsers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w> </span><span class=c1>// 인원수</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>requestPerUser</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w> </span><span class=c1>// 한사람당 요청개수</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 포인트 초기화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1L</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>numberOfUsers</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>userPointRepository</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>0L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ExecutorService</span><span class=w> </span><span class=n>executor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Executors</span><span class=p>.</span><span class=na>newFixedThreadPool</span><span class=p>(</span><span class=n>5</span><span class=p>);</span><span class=w> </span><span class=c1>// 스레드풀: 5개. (요청 5개 동시에 실행가능)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>CountDownLatch</span><span class=w> </span><span class=n>latch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CountDownLatch</span><span class=p>(</span><span class=n>numberOfUsers</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>requestPerUser</span><span class=p>);</span><span class=w> </span><span class=c1>// 10 * 10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>long</span><span class=w> </span><span class=n>chargeAmount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1000L</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// when</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1L</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>numberOfUsers</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>ChargeRequest</span><span class=w> </span><span class=n>request</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ChargeRequest</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>chargeAmount</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 유저 1명당 10번을 요청한다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>requestPerUser</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>long</span><span class=w> </span><span class=n>uid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=p>(</span><span class=n>uid</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>1L</span><span class=p>)</span><span class=w> </span><span class=n>sleep</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>pointService</span><span class=p>.</span><span class=na>charge</span><span class=p>(</span><span class=n>request</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>latch</span><span class=p>.</span><span class=na>countDown</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>latch</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>sleep</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;::: 테스트 종료후 유저별 보유포인트 조회 :::&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1L</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>numberOfUsers</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>long</span><span class=w> </span><span class=n>actualPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userPointRepository</span><span class=p>.</span><span class=na>findById</span><span class=p>(</span><span class=n>id</span><span class=p>).</span><span class=na>point</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;유저 ID {} 의 보유포인트: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>actualPoint</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=n>1L</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>numberOfUsers</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>long</span><span class=w> </span><span class=n>actualPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userPointRepository</span><span class=p>.</span><span class=na>findById</span><span class=p>(</span><span class=n>id</span><span class=p>).</span><span class=na>point</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>assertEquals</span><span class=p>(</span><span class=n>requestPerUser</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>chargeAmount</span><span class=p>,</span><span class=w> </span><span class=n>actualPoint</span><span class=p>,</span><span class=s>&#34;UserPoint id &#34;</span><span class=o>+</span><span class=n>id</span><span class=o>+</span><span class=w> </span><span class=s>&#34;인 회원의 포인트는 예상금액과 다릅니다: &#34;</span><span class=o>+</span><span class=w> </span><span class=n>actualPoint</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;원&#34;</span><span class=w> </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>특정스레드를 슬립을 시키지 않은채 동시성제어 테스트를 실행시킨 결과</li></ul><blockquote><ul><li><p>synchronized : 성공 (44s)</p></li><li><p>ReentrantLock : 성공 (31s)</p></li></ul></blockquote><p>ReentrantLock 이 상대적으로 실행속도가 빠른편입니다. 공정성을 제공하고 해시맵으로 락을 구분하기 때문입니다. 그에반면 락의 구분이 없습니다. synchronized는 <code>synchronized</code> 키워드로 부여된 charge함수블록이 임계구역임을 나타냅니다.</p><p>만일 특정 유저에게만 1초의 Thread.sleep 을 했을 경우 synchronized와 ReentrantLock 간의 실행시간차이가 점점 더 커집니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1L</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>numberOfUsers</span><span class=p>;</span><span class=w> </span><span class=n>id</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ChargeRequest</span><span class=w> </span><span class=n>request</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ChargeRequest</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>chargeAmount</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 유저 1명당 10번을 요청한다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>requestPerUser</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>long</span><span class=w> </span><span class=n>uid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>uid</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>1L</span><span class=p>)</span><span class=w> </span><span class=n>sleep</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=c1>// id=1 번인 유저는 1초 대기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>pointService</span><span class=p>.</span><span class=na>charge</span><span class=p>(</span><span class=n>request</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>latch</span><span class=p>.</span><span class=na>countDown</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><ul><li><p>synchronized : 성공 (47s)</p></li><li><p>ReentrantLock : 성공 (33s)</p></li></ul></blockquote><hr><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><ul><li><p>현재 synchronized, ReentrantLock 등 JVM내에서만 활용되는 락이며 하나의 서버에서는 가능합니다.</p></li><li><p>synchronized 은 임계구역을 블록으로 지정하여 나타내지만 단순하게 동시성제어를 처리하는데 좋습니다.</p></li><li><p>synchronized 는 간단하게 한개의 스레드에만 접근하도록 설정해줍니다. 공유데이터에 하나의 스레드만이 접근이 가능하다는 조건이 하나의 프로세스에만 보장됩니다. 이러한 특징때문에 scale-out 하게되면 서버가 여러대일때 동시성을 보장하지 않습니다.</p></li><li><p>ReentrantLock 은 임계구역을 진입하기전에는 lock를 임계구역을 빠져나오면 unlock 으로 명시하여 synchronized 보다는 정교하게 나타냅니다.</p></li><li><p>동시성제어와 관련된 테스팅은 작성할 때는 단위테스트보다 통합테스트가 적합합니다.</p></li><li><p>선입선출 자료구조인 큐(queue)를 이용해서 동시성제어 를 해결할 수 있습니다. 하지만 Lock다르게 여러 요청이 한번에 들어와도 각 요청을 큐에넣고 순차적으로 처리하는방식입니다. 순서가 있기 때문에 동시성을 제거시켜서 해결하는 방법입니다.</p></li><li><p>참고</p><ul><li><a href=https://anytech.medium.com/java-synchronized-vs-reentrantlock-which-lock-should-i-use-really-0cd8bd7cd3e5>Java Synchronized vs ReentrantLock: In-Depth Comparison for Optimal Locking Choice</a></li><li><a href=https://dkswhdgur246.tistory.com/76>Java의 동기화 기법 - synchronized & ReentrantLock 에 대해</a></li><li><a href=https://velog.io/@pak4184/%EC%8A%A4%ED%94%84%EB%A7%81%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%B2%98%EB%A6%AC-5azfj19q>스프링에서의 동시성 처리</a></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://loveAlakazam.github.io/blog/docs/hh-08-week01-remind/><span class=title>« Prev</span><br><span>항해99 1주차 회고 (WIL)</span>
</a><a class=next href=https://loveAlakazam.github.io/blog/docs/object-responsibility/><span class=title>Next »</span><br><span>객체의 책임(도메인 주도)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://loveAlakazam.github.io/blog/>EK Dev Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>