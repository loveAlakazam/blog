<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RDBMS 락을 사용한 동시성문제 해결 | EK Dev Blog</title>
<meta name=keywords content><meta name=description content="동시성 문제 (RaceCondition) 여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때 공유자원의 데이터의 정합성이 깨지는 현상.
데드락 (DeadLock) 1 2 3 4 화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다. - 손님 A가 립밤 1개를 집었다. - 손님 B가 스킨로션 1개를 집었다. 손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.
손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고 손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다."><meta name=author content><link rel=canonical href=https://loveAlakazam.github.io/blog/docs/rdbms-locks/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://loveAlakazam.github.io/blog/docs/rdbms-locks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://loveAlakazam.github.io/blog/docs/rdbms-locks/"><meta property="og:site_name" content="EK Dev Blog"><meta property="og:title" content="RDBMS 락을 사용한 동시성문제 해결"><meta property="og:description" content="동시성 문제 (RaceCondition) 여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때 공유자원의 데이터의 정합성이 깨지는 현상.
데드락 (DeadLock) 1 2 3 4 화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다. - 손님 A가 립밤 1개를 집었다. - 손님 B가 스킨로션 1개를 집었다. 손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.
손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고 손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="RDBMS 락을 사용한 동시성문제 해결"><meta name=twitter:description content="동시성 문제 (RaceCondition) 여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때 공유자원의 데이터의 정합성이 깨지는 현상.
데드락 (DeadLock) 1 2 3 4 화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다. - 손님 A가 립밤 1개를 집었다. - 손님 B가 스킨로션 1개를 집었다. 손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.
손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고 손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://loveAlakazam.github.io/blog/docs/"},{"@type":"ListItem","position":2,"name":"RDBMS 락을 사용한 동시성문제 해결","item":"https://loveAlakazam.github.io/blog/docs/rdbms-locks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RDBMS 락을 사용한 동시성문제 해결","name":"RDBMS 락을 사용한 동시성문제 해결","description":"동시성 문제 (RaceCondition) 여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때 공유자원의 데이터의 정합성이 깨지는 현상.\n데드락 (DeadLock) 1 2 3 4 화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다. - 손님 A가 립밤 1개를 집었다. - 손님 B가 스킨로션 1개를 집었다. 손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.\n손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고 손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다.","keywords":[],"articleBody":"동시성 문제 (RaceCondition) 여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때 공유자원의 데이터의 정합성이 깨지는 현상.\n데드락 (DeadLock) 1 2 3 4 화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다. - 손님 A가 립밤 1개를 집었다. - 손님 B가 스킨로션 1개를 집었다. 손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.\n손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고 손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다.\n즉 둘중한명이 내려놓기까지 아무것도 못하고 무한정 기다려야한다. 이것이 데드락이다.\n아무것도 못하는 상태고 기다리는 상태가 Blocking 이다. 여기까지만해도 우리가 알고있는 데드락이다.\n이 데드락은, 상호배제(Mutual Exclusion) 의 문제점이기도하다. 상호배제란 공유자원을 먼저 사용하게되면 다른 스레드의 접근을 막기 위해 락(Lock)을 걸어놓는다. 사용을 끝내면 락을 해제하는 식이다.\n데이터베이스에서도 동시성이 깨지는 현상이 있지만 데이터베이스에서도 락이 존재하지만 멀티스레드의 관점과는 약간의 차이가 있다.\n데이터베이스 락 데이터베이스는 Lock의 유효범위(임계구역)를 고려해야하며 트랜잭션 범위 내에서 락이 획득되면 트랜잭션이 종료될 때까지 락을 해제한다.\n트랜잭션의 락의 시작과 끝이 길 때 1 2 3 4 5 6 7 8 9 10 Transaction { Lock(); . . . . . . UnLock() } 트랜잭션의 락의 시작과 끝이 짧을때 1 2 3 4 5 6 7 8 9 10 Transaction { . . Lock(); . UnLock() . . . } 락의 유효범위가 좁으면 금방 실행할 수 있지만, 유효범위가 넓으면 실행하는데 시간이 걸린다.\n커밋의 작업단위가 길어진다면 어떻게 될까? 다른 트랜잭션은 끝날때까지 기다려야한다. 그러므로 다른 트랜잭션의 병목현상을 막기위해서는 트랜잭션의 범위를 좁히는게 좋다.\n낙관적락 과 비관적 락 우리는 ‘짝’, ‘나는솔로’ 와 같은 방송 예능에서도 낙관적락과 비관적 락을 비유할 수 있다. 남자A 와 남자B 는 여자C 에게 호감이 있고 데이트를 신청했다.\n여자C 는 남자A 와 데이트를 수락했다.\n이 상황에 대한 남자B의 태도에 따라 낙관적락 과 비관적 락이 결정된다.\n낙관적락 (Optimistic Lock) 낙관적락의 남자B 는 이 결과를 받아들이고 아예 빠른 포기를 하거나\n몇번 재시도를 해보지만 여자 C의 마음을 얻지 못하면 그냥 포기한다.\n실생활과 연관지어도 아직 이게 왜 낙관적락과 무슨상관이냐고 할 수 도 있겠다. 쿼리문 실습예제를 통해서 왜 낙관적락은 빠른포기를 하는 남자인지를 증명 해보겠다.\n낙관적락은 논리적인 락이다. 실제로 데이터베이스의 락과 다르다. 데이터에 버젼이 있는데 조회를 할때는 Version이 변하지 않는다. 반면 업데이트할 때는 Version을 확인한다. Version이 다르면 업데이트 버젼이 다르므로 충돌이 된거다. version이 다르다면 이미 다른 트랜잭션에서 업데이트를 한것이라고 볼 수있다. 충돌이 발생하면 실패된 트랜잭션은 롤백처리된다. 이후에 다시 재시도를 할 기회를 주거나 빠른 예외를 리스폰스하면된다. 비관적락 (Pessimistic Lock) 비관적락의 남자B 는 이 절대 포기하지 않고 여자 C를 원한다.\n즉 여자C 가 다가올 때까지 계속 우직하게 기다린다.\n이론적인 개념을 먼저 정리를 해보자면, 비관적락은 데이터베이스 수준의 물리적인 락이다. 물리적락은 대표적으로 X-Lock 과 S-Lock 이 있다.\n먼저 두개의 락의 공통점이 있다. 락을 얻지 못한 다른 트랜잭션들은 UPDATE 를 할 수 없다.\nX-Lock\n실생활 예시로는 “사생활 보호필름\"이다. 사생활 보호필름은 옆에있는 다른사람이 내 폰화면의 내용을 볼 수 없다. (만지는건 당연히 안된다.)\nX-Lock은 다른트랜잭션은 데이터로우에 읽기/쓰기 수행을 할 수 없다. 락을 얻은 트랜잭션은 데이터로우에 대한 읽기/쓰기 수행을 할 수있다. S-Lock\n실생활 예시로는 “보호필름” 이다. 그냥 휴대폰 보호필름은 옆에있는 다른 사람이 내 폰화면의 내용을 볼 수 있다. (만지는건.. 범죄다..)\nS-Lock은 다른트랜잭션은 데이터로우에 읽기 가 가능하며, 여러개의 트랜잭션이 동일한 Row에 대해 S-Lock을 따로 소유한다. 이 물리적인락이 성공할때까지 무한정 기다린다. 만일 데이터가 많아져서 수많은 데이터가 기다려야된다면 무한정 기다리다가 TimeOut 이 발생할 수 있다.\n그런데 이론 내용만으로는 왜 무한정으로 기다리는지 납득이 안된다. 그래서 콘서트예약서비스의 예를 들어서 해보자.\n콘서트 서비스에서 적용한 낙관적락과 비관적락 회고 나는 낙관적락과 S-Lock을 동일하게 본 정말 바보같은 생각을 했었다. 엄연히 다른 개념인데 너무 대충 블로그글들을 발췌해서 복붙하는 형식으로 공부를 해온 내 모습을 반성했다.\n","wordCount":"548","inLanguage":"en","datePublished":"2025-04-22T00:00:00Z","dateModified":"2025-04-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://loveAlakazam.github.io/blog/docs/rdbms-locks/"},"publisher":{"@type":"Organization","name":"EK Dev Blog","logo":{"@type":"ImageObject","url":"https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loveAlakazam.github.io/blog/ accesskey=h title="EK Dev Blog (Alt + H)"><img src=https://loveAlakazam.github.io/apple-touch-icon.png alt aria-label=logo height=35>EK Dev Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eunkangchoi.github.io/resume/ title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loveAlakazam.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://loveAlakazam.github.io/blog/docs/>Docs</a></div><h1 class="post-title entry-hint-parent">RDBMS 락을 사용한 동시성문제 해결</h1><div class=post-meta><span title='2025-04-22 00:00:00 +0000 UTC'>April 22, 2025</span></div></header><div class=post-content><h2 id=동시성-문제-racecondition>동시성 문제 (RaceCondition)<a hidden class=anchor aria-hidden=true href=#동시성-문제-racecondition>#</a></h2><p>여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때
공유자원의 데이터의 정합성이 깨지는 현상.</p><hr><h2 id=데드락-deadlock>데드락 (DeadLock)<a hidden class=anchor aria-hidden=true href=#데드락-deadlock>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>-</span> 손님 A가 립밤 1개를 집었다.
</span></span><span class=line><span class=cl><span class=k>-</span> 손님 B가 스킨로션 1개를 집었다.
</span></span></code></pre></td></tr></table></div></div><p>손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.</p><p>손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고
손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다.</p><p>즉 둘중한명이 내려놓기까지 아무것도 못하고 무한정 기다려야한다. 이것이 데드락이다.</p><p>아무것도 못하는 상태고 기다리는 상태가 Blocking 이다.
여기까지만해도 우리가 알고있는 데드락이다.</p><p>이 데드락은, 상호배제(Mutual Exclusion) 의 문제점이기도하다.
상호배제란 공유자원을 먼저 사용하게되면 다른 스레드의 접근을 막기 위해 락(Lock)을 걸어놓는다.
사용을 끝내면 락을 해제하는 식이다.</p><p>데이터베이스에서도 동시성이 깨지는 현상이 있지만 데이터베이스에서도 락이 존재하지만 멀티스레드의 관점과는 약간의 차이가 있다.</p><hr><h2 id=데이터베이스-락>데이터베이스 락<a hidden class=anchor aria-hidden=true href=#데이터베이스-락>#</a></h2><p>데이터베이스는 Lock의 유효범위(임계구역)를 고려해야하며
트랜잭션 범위 내에서 락이 획득되면 트랜잭션이 종료될 때까지 락을 해제한다.</p><ul><li><ol><li>트랜잭션의 락의 시작과 끝이 길 때</li></ol></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Transaction <span class=o>{</span>
</span></span><span class=line><span class=cl>    Lock<span class=o>()</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    UnLock<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><ol start=2><li>트랜잭션의 락의 시작과 끝이 짧을때</li></ol></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Transaction <span class=o>{</span>
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    Lock<span class=o>()</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    UnLock<span class=o>()</span>
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>락의 유효범위가 좁으면 금방 실행할 수 있지만, 유효범위가 넓으면 실행하는데 시간이 걸린다.</p><p>커밋의 작업단위가 길어진다면 어떻게 될까? 다른 트랜잭션은 끝날때까지 기다려야한다. 그러므로 다른 트랜잭션의 병목현상을 막기위해서는 트랜잭션의 범위를 좁히는게 좋다.</p><hr><h2 id=낙관적락-과-비관적-락>낙관적락 과 비관적 락<a hidden class=anchor aria-hidden=true href=#낙관적락-과-비관적-락>#</a></h2><blockquote><p>우리는 &lsquo;짝&rsquo;, &lsquo;나는솔로&rsquo; 와 같은 방송 예능에서도 낙관적락과 비관적 락을 비유할 수 있다.
남자A 와 남자B 는 여자C 에게 호감이 있고 데이트를 신청했다.</p><p>여자C 는 남자A 와 데이트를 수락했다.</p><p>이 상황에 대한 남자B의 태도에 따라 낙관적락 과 비관적 락이 결정된다.</p></blockquote><h3 id=낙관적락-optimistic-lock>낙관적락 (Optimistic Lock)<a hidden class=anchor aria-hidden=true href=#낙관적락-optimistic-lock>#</a></h3><blockquote><p>낙관적락의 남자B 는 이 결과를 받아들이고 아예 빠른 포기를 하거나</p><p>몇번 재시도를 해보지만 여자 C의 마음을 얻지 못하면 그냥 포기한다.</p></blockquote><p>실생활과 연관지어도 아직 이게 왜 낙관적락과 무슨상관이냐고 할 수 도 있겠다.
쿼리문 실습예제를 통해서 왜 낙관적락은 빠른포기를 하는 남자인지를 증명 해보겠다.</p><p><img alt=optimistic-lock loading=lazy src=../images/optimistic-lock.png></p><ul><li>낙관적락은 논리적인 락이다. 실제로 데이터베이스의 락과 다르다.</li><li>데이터에 버젼이 있는데 조회를 할때는 Version이 변하지 않는다.
반면 업데이트할 때는 Version을 확인한다. Version이 다르면 업데이트 버젼이 다르므로 충돌이 된거다. version이 다르다면 이미 다른 트랜잭션에서 업데이트를 한것이라고 볼 수있다.
충돌이 발생하면 실패된 트랜잭션은 롤백처리된다. 이후에 다시 재시도를 할 기회를 주거나 빠른 예외를 리스폰스하면된다.</li></ul><h3 id=비관적락-pessimistic-lock>비관적락 (Pessimistic Lock)<a hidden class=anchor aria-hidden=true href=#비관적락-pessimistic-lock>#</a></h3><blockquote><p>비관적락의 남자B 는 이 절대 포기하지 않고 여자 C를 원한다.</p><p>즉 여자C 가 다가올 때까지 계속 우직하게 기다린다.</p></blockquote><p>이론적인 개념을 먼저 정리를 해보자면, 비관적락은 데이터베이스 수준의 물리적인 락이다.
물리적락은 대표적으로 <code>X-Lock</code> 과 <code>S-Lock</code> 이 있다.</p><p>먼저 두개의 락의 공통점이 있다. <strong>락을 얻지 못한 다른 트랜잭션들은 UPDATE 를 할 수 없다.</strong></p><ul><li><p>X-Lock</p><blockquote><p>실생활 예시로는 &ldquo;사생활 보호필름"이다. 사생활 보호필름은 옆에있는 다른사람이 내 폰화면의 내용을 볼 수 없다. (만지는건 당연히 안된다.)</p></blockquote><ul><li>X-Lock은 다른트랜잭션은 데이터로우에 읽기/쓰기 수행을 할 수 없다. 락을 얻은 트랜잭션은 데이터로우에 대한 읽기/쓰기 수행을 할 수있다.</li></ul></li><li><p>S-Lock</p><blockquote><p>실생활 예시로는 &ldquo;보호필름&rdquo; 이다. 그냥 휴대폰 보호필름은 옆에있는 다른 사람이 내 폰화면의 내용을 볼 수 있다. (만지는건.. 범죄다..)</p></blockquote><ul><li>S-Lock은 다른트랜잭션은 데이터로우에 읽기 가 가능하며, 여러개의 트랜잭션이 동일한 Row에 대해 S-Lock을 따로 소유한다.</li></ul></li></ul><p>이 물리적인락이 성공할때까지 무한정 기다린다. 만일 데이터가 많아져서 수많은 데이터가 기다려야된다면 무한정 기다리다가 TimeOut 이 발생할 수 있다.</p><p>그런데 이론 내용만으로는 왜 무한정으로 기다리는지 납득이 안된다. 그래서 콘서트예약서비스의 예를 들어서 해보자.</p><hr><ul><li><a href=https://github.com/loveAlakazam/hh-08-concert/wiki/07_RDBMS_%EB%9D%BD%EC%9D%84%ED%99%9C%EC%9A%A9%ED%95%9C_%EB%8F%99%EC%8B%9C%EC%84%B1%EC%A0%9C%EC%96%B4%EB%B3%B4%EA%B3%A0%EC%84%9C>콘서트 서비스에서 적용한 낙관적락과 비관적락</a></li></ul><hr><h2 id=회고>회고<a hidden class=anchor aria-hidden=true href=#회고>#</a></h2><p>나는 낙관적락과 S-Lock을 동일하게 본 정말 바보같은 생각을 했었다. 엄연히 다른 개념인데 너무 대충 블로그글들을 발췌해서 복붙하는 형식으로 공부를 해온 내 모습을 반성했다.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://loveAlakazam.github.io/blog/docs/hh-08-week06-remind/><span class=title>« Prev</span><br><span>항해99 6주차 회고(WIL)</span>
</a><a class=next href=https://loveAlakazam.github.io/blog/docs/rdbms-index/><span class=title>Next »</span><br><span>RDBMS(Mysql)에서의 인덱스 개념 정리</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://loveAlakazam.github.io/blog/>EK Dev Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>