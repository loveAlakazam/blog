<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RDBMS(Mysql)에서의 인덱스 개념 정리 | EK Dev Blog</title>
<meta name=keywords content><meta name=description content="만능은 없다. TradeOff는 있다. 읽기 성능이 좋으면 쓰기성능이 구리고, 쓰기성능이 좋으면 읽기성능에 구려진다.
정규화 쓰기성능을 높임으로써 데이터 중복을 줄이고 일관성을 높인다.
반정규화 읽기성능을 높임으로써 일부 중복을 허용한다.
트랜잭션 격리 수준 Uncommitted Read - 커밋되지 않은 읽기 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근하게 할 수 있는 격리수준 DirtyRead: 커밋되지 않은 트랜잭션에 접근해서 아직 정상반영되지 않은 데이터를 읽는 현상 (해당 데이터는 롤백되어 없어질 수도 있다) Committed Read - 커밋된 읽기 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 하는 격리수준 Non-Repeatable Read: 하나의 트랜잭션에서 동일한 SELECT 쿼리문을 실행했을 때 커밋전의 데이터와 커밋후의 데이터가 읽히면서 다른결과가 생기는 현상 Repeatable Read - 반복가능한 읽기 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준"><meta name=author content><link rel=canonical href=https://loveAlakazam.github.io/blog/docs/rdbms-index/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://loveAlakazam.github.io/blog/docs/rdbms-index/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://loveAlakazam.github.io/blog/docs/rdbms-index/"><meta property="og:site_name" content="EK Dev Blog"><meta property="og:title" content="RDBMS(Mysql)에서의 인덱스 개념 정리"><meta property="og:description" content="만능은 없다. TradeOff는 있다. 읽기 성능이 좋으면 쓰기성능이 구리고, 쓰기성능이 좋으면 읽기성능에 구려진다.
정규화 쓰기성능을 높임으로써 데이터 중복을 줄이고 일관성을 높인다.
반정규화 읽기성능을 높임으로써 일부 중복을 허용한다.
트랜잭션 격리 수준 Uncommitted Read - 커밋되지 않은 읽기 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근하게 할 수 있는 격리수준 DirtyRead: 커밋되지 않은 트랜잭션에 접근해서 아직 정상반영되지 않은 데이터를 읽는 현상 (해당 데이터는 롤백되어 없어질 수도 있다) Committed Read - 커밋된 읽기 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 하는 격리수준 Non-Repeatable Read: 하나의 트랜잭션에서 동일한 SELECT 쿼리문을 실행했을 때 커밋전의 데이터와 커밋후의 데이터가 읽히면서 다른결과가 생기는 현상 Repeatable Read - 반복가능한 읽기 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-04-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-14T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="RDBMS(Mysql)에서의 인덱스 개념 정리"><meta name=twitter:description content="만능은 없다. TradeOff는 있다. 읽기 성능이 좋으면 쓰기성능이 구리고, 쓰기성능이 좋으면 읽기성능에 구려진다.
정규화 쓰기성능을 높임으로써 데이터 중복을 줄이고 일관성을 높인다.
반정규화 읽기성능을 높임으로써 일부 중복을 허용한다.
트랜잭션 격리 수준 Uncommitted Read - 커밋되지 않은 읽기 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근하게 할 수 있는 격리수준 DirtyRead: 커밋되지 않은 트랜잭션에 접근해서 아직 정상반영되지 않은 데이터를 읽는 현상 (해당 데이터는 롤백되어 없어질 수도 있다) Committed Read - 커밋된 읽기 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 하는 격리수준 Non-Repeatable Read: 하나의 트랜잭션에서 동일한 SELECT 쿼리문을 실행했을 때 커밋전의 데이터와 커밋후의 데이터가 읽히면서 다른결과가 생기는 현상 Repeatable Read - 반복가능한 읽기 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://loveAlakazam.github.io/blog/docs/"},{"@type":"ListItem","position":2,"name":"RDBMS(Mysql)에서의 인덱스 개념 정리","item":"https://loveAlakazam.github.io/blog/docs/rdbms-index/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RDBMS(Mysql)에서의 인덱스 개념 정리","name":"RDBMS(Mysql)에서의 인덱스 개념 정리","description":"만능은 없다. TradeOff는 있다. 읽기 성능이 좋으면 쓰기성능이 구리고, 쓰기성능이 좋으면 읽기성능에 구려진다.\n정규화 쓰기성능을 높임으로써 데이터 중복을 줄이고 일관성을 높인다.\n반정규화 읽기성능을 높임으로써 일부 중복을 허용한다.\n트랜잭션 격리 수준 Uncommitted Read - 커밋되지 않은 읽기 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근하게 할 수 있는 격리수준 DirtyRead: 커밋되지 않은 트랜잭션에 접근해서 아직 정상반영되지 않은 데이터를 읽는 현상 (해당 데이터는 롤백되어 없어질 수도 있다) Committed Read - 커밋된 읽기 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 하는 격리수준 Non-Repeatable Read: 하나의 트랜잭션에서 동일한 SELECT 쿼리문을 실행했을 때 커밋전의 데이터와 커밋후의 데이터가 읽히면서 다른결과가 생기는 현상 Repeatable Read - 반복가능한 읽기 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준","keywords":[],"articleBody":"만능은 없다. TradeOff는 있다. 읽기 성능이 좋으면 쓰기성능이 구리고, 쓰기성능이 좋으면 읽기성능에 구려진다.\n정규화 쓰기성능을 높임으로써 데이터 중복을 줄이고 일관성을 높인다.\n반정규화 읽기성능을 높임으로써 일부 중복을 허용한다.\n트랜잭션 격리 수준 Uncommitted Read - 커밋되지 않은 읽기 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근하게 할 수 있는 격리수준 DirtyRead: 커밋되지 않은 트랜잭션에 접근해서 아직 정상반영되지 않은 데이터를 읽는 현상 (해당 데이터는 롤백되어 없어질 수도 있다) Committed Read - 커밋된 읽기 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 하는 격리수준 Non-Repeatable Read: 하나의 트랜잭션에서 동일한 SELECT 쿼리문을 실행했을 때 커밋전의 데이터와 커밋후의 데이터가 읽히면서 다른결과가 생기는 현상 Repeatable Read - 반복가능한 읽기 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준\nMVCC를 통해 Undo 로그를 기반으로 동일한 데이터가 조회되도록 보장하여 Non-Repeatabe Read 문제를 해결한다.\nORACLE 와 같이 Repeatable Read를 지원하지 않는 데이터베이스에서는 배타락을 이용해서 문제를 해결한다.\nPhantom Read: 하나의 트랜잭션내에서 동일한 SELECT 쿼리의 결과 레코드수가 달라지는 현상\nInnoDB 엔진에 의해 SELECT ~ FOR UPDATE 구문을 지원해주며, Next Key Lock 형태의 배타락을 지원해주기 때문에 MYSQL 에서는 Phantom Read가 발생하지 않는다 Serializable 모든 트랜잭션을 순차적으로 실행시켜주는 격리 수준 트랜잭션이 서로 끼어들 수 있는 상황이 없으므로 데이터의 부정합 문제는 발생하지 않는다. 트랜잭션이 동기적으로 처리되면서 처리속도 저하가 발생한다 S-LOCK으로 조회후 Update하려고 할때 대기상태가 되므로 Dead Lock 문제가 발생한다 InnoDB의 격리수준 기본값은 Repeatable Read 이다. Mysql InnoDB에서는 MVCC(Multi-Version-Concurrency Control)을 사용해서 Phantom Read도 방지할 수 있다. 격리수준 설정방법 전역 설정 1 SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; 세션설정 1 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; 트랜잭션 시작시 설정하기 1 2 START TRANSACTION; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; MVCC(Multi-Version-Concurrency Control) 참고: 12가지 디자인패턴으로 알아보는 클라우드 네이티브 마이크로서비스 아키텍쳐 - 김형일, 박진현 / AWS Summit Seoul 2023 인덱스(Index) 위의 예시처럼 책의 목차를 보면, 각 목차별로 페이지를 기재해준다. 검색속도 향상을 위해서 데이터(data row)를 식별가능하도록 저장하는 객체이다. 검색속도 향상으로 데이터베이스 부하 감소를 목적으로 한다. 인덱스 개념 특정 컬럼으로 인덱스를 설정하면, 해당 컬럼의 값을 정렬하여 데이터를 적재해두어 해당 컬럼의 조회 성능을 향상시킨다. 1~100까지의 수를 랜덤하게 펼쳐두고 30보다 작은 값을 찾는다. 1~100까지의 수를 오름차순으로 정렬하고 30보다 작은 값을 찾는다. 인덱스는 조회성능을 높일 수 있지만 아래 사항을 고려하여 설계해야한다. 한번에 찾을 수 있는 값인가? - 데이터 중복이 적은 컬럼 인덱스 재정렬을 최소화할 수 있는가? - 데이터 삽입, 수정이 적은 컬럼. 인덱스의 목적은 검색이다 - 조회에 자주사용되는 컬럼 너무 많지 않은 인덱스 - 인덱스도 별도의 공간을 차지. 인덱스도 공간을 차지하기 때문에 너무 많이 있어도 문제가 생긴다. 인덱스 조정때문에 쓰기연산인 데이터 삽입/수정/삭제 연산 성능이 하락될 수 있다. 그럼 인덱스는 언제 필요할까? 데이터가 너무 많아서 조건에 부합하는 결과데이터를 찾는데 오래걸릴 경우 단일 인덱스 1개 컬럼으로 구성된 인덱스 복합 인덱스 2개이상의 컬럼으로 구성된 인덱스 카디널리티가 높은 컬럼순으로 구성해야 검색속도를 높일 수 있다. 인덱스의 컬럼 순서와 조건 조회 순서가 일치하지 않으면 인덱스를 이용하지 않는다. Covering 인덱스 특정 쿼리를 충족시키는데 필요한 모든 데이터를 포함하는 인덱스 모든컬럼의 조회대상, 조회 조건에 포함된다면 데이터를 찾기위해서 Row에 접근할 필요가 없으므로, 인덱스 스캔만 발생하므로 높은 조회 성능을 가진다. 카디널리티(Cardinality) 정의: 테이블의 열(column)이 가지는 고유한 값의 개수를 의미한다. ID GENDER 1 M 2 F 3 F 4 F 5 M gender 컬럼의 카디널리티개수: 2개 (M/F) ID 컬럼의 카디널리티개수: 5개 (모두 고유하다) 종류\n높은 카디널리티: 고유값이 많은 컬럼 예) 주민등록번호, 이메일, 고유 PK 식별자 ID 중간 카디널리티: 값이 적당히 중복되는 컬럼 예) 우편번호, 도시이름, 이름 낮은 카디널리티: 값이 거의 중복되는 컬럼 예) 성별(M/F), 국가(대한민국) 카디널리티와 인덱스의 연관관계\n카디널리티가 높을수록 인덱스 성능이 좋다. 왜냐하면 인덱스를 통해서 많은 데이터를 빠르게 걸러낼 수 있기 때문이다. 카디널리티가 낮을수록 컬럼에 인덱스를 걸게되면 인덱스보다는 테이블 풀스캔이 더 효율적일 수 있다. 관계형 모델에서의 카디널리티(엔티티 관계)\n1:1 1:N N:M Sync Schedule Strategy 통계 데이터를 활용하는 방법이다.\n실시간성과 정합성의 Trade-Off 를 극복하기위해서 데이터베이스 I/O를 줄이고 언젠간 정합성이 맞아 떨어지는 환경을 구성하는 전략이다.\n자주 삽입/수정하는 데이터에 대해서 인덱스를 적용하게되면 인덱스의 재조정으로 인해서 성능이 하락될 수 있다. 인덱스도 공간을 차지할 수 있으므로, 인덱스를 통해서 읽어야할 데이터레코드가 전체데이터베이스에서 20~25% 넘게 차지한다면 인덱스로 읽기보다는 테이블의 데이터를 직접 읽는 것이 더 효율적이다.\n","wordCount":"628","inLanguage":"en","datePublished":"2025-04-14T00:00:00Z","dateModified":"2025-04-14T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://loveAlakazam.github.io/blog/docs/rdbms-index/"},"publisher":{"@type":"Organization","name":"EK Dev Blog","logo":{"@type":"ImageObject","url":"https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loveAlakazam.github.io/blog/ accesskey=h title="EK Dev Blog (Alt + H)"><img src=https://loveAlakazam.github.io/apple-touch-icon.png alt aria-label=logo height=35>EK Dev Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eunkangchoi.github.io/resume/ title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loveAlakazam.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://loveAlakazam.github.io/blog/docs/>Docs</a></div><h1 class="post-title entry-hint-parent">RDBMS(Mysql)에서의 인덱스 개념 정리</h1><div class=post-meta><span title='2025-04-14 00:00:00 +0000 UTC'>April 14, 2025</span></div></header><div class=post-content><h1 id=만능은-없다-tradeoff는-있다>만능은 없다. TradeOff는 있다.<a hidden class=anchor aria-hidden=true href=#만능은-없다-tradeoff는-있다>#</a></h1><p>읽기 성능이 좋으면 쓰기성능이 구리고, 쓰기성능이 좋으면 읽기성능에 구려진다.</p><h2 id=정규화>정규화<a hidden class=anchor aria-hidden=true href=#정규화>#</a></h2><p><strong>쓰기성능을 높임</strong>으로써 데이터 중복을 줄이고 일관성을 높인다.</p><h2 id=반정규화>반정규화<a hidden class=anchor aria-hidden=true href=#반정규화>#</a></h2><p><strong>읽기성능을 높임</strong>으로써 일부 중복을 허용한다.</p><hr><h1 id=트랜잭션-격리-수준>트랜잭션 격리 수준<a hidden class=anchor aria-hidden=true href=#트랜잭션-격리-수준>#</a></h1><h2 id=uncommitted-read---커밋되지-않은-읽기>Uncommitted Read - 커밋되지 않은 읽기<a hidden class=anchor aria-hidden=true href=#uncommitted-read---커밋되지-않은-읽기>#</a></h2><ul><li>다른 트랜잭션에서 커밋되지 않은 데이터에도 접근하게 할 수 있는 격리수준</li><li>DirtyRead: 커밋되지 않은 트랜잭션에 접근해서 아직 정상반영되지 않은 데이터를 읽는 현상 (해당 데이터는 롤백되어 없어질 수도 있다)</li></ul><h2 id=committed-read---커밋된-읽기>Committed Read - 커밋된 읽기<a hidden class=anchor aria-hidden=true href=#committed-read---커밋된-읽기>#</a></h2><ul><li>다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 하는 격리수준</li><li>Non-Repeatable Read: 하나의 트랜잭션에서 동일한 SELECT 쿼리문을 실행했을 때 커밋전의 데이터와 커밋후의 데이터가 읽히면서 다른결과가 생기는 현상</li></ul><h2 id=repeatable-read---반복가능한-읽기>Repeatable Read - 반복가능한 읽기<a hidden class=anchor aria-hidden=true href=#repeatable-read---반복가능한-읽기>#</a></h2><ul><li><p>커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준</p></li><li><p>MVCC를 통해 Undo 로그를 기반으로 동일한 데이터가 조회되도록 보장하여 Non-Repeatabe Read 문제를 해결한다.</p></li><li><p>ORACLE 와 같이 Repeatable Read를 지원하지 않는 데이터베이스에서는 배타락을 이용해서 문제를 해결한다.</p></li><li><p>Phantom Read: 하나의 트랜잭션내에서 동일한 SELECT 쿼리의 결과 레코드수가 달라지는 현상</p><ul><li>InnoDB 엔진에 의해 SELECT ~ FOR UPDATE 구문을 지원해주며, Next Key Lock 형태의 배타락을 지원해주기 때문에 MYSQL 에서는 Phantom Read가 발생하지 않는다</li></ul></li></ul><h2 id=serializable>Serializable<a hidden class=anchor aria-hidden=true href=#serializable>#</a></h2><ul><li>모든 트랜잭션을 순차적으로 실행시켜주는 격리 수준</li><li>트랜잭션이 서로 끼어들 수 있는 상황이 없으므로 데이터의 부정합 문제는 발생하지 않는다.</li><li>트랜잭션이 동기적으로 처리되면서 처리속도 저하가 발생한다</li><li>S-LOCK으로 조회후 Update하려고 할때 대기상태가 되므로 Dead Lock 문제가 발생한다</li></ul><hr><h2 id=innodb의-격리수준>InnoDB의 격리수준<a hidden class=anchor aria-hidden=true href=#innodb의-격리수준>#</a></h2><ul><li>기본값은 Repeatable Read 이다.</li><li>Mysql InnoDB에서는 MVCC(Multi-Version-Concurrency Control)을 사용해서 Phantom Read도 방지할 수 있다.</li></ul><h3 id=격리수준-설정방법>격리수준 설정방법<a hidden class=anchor aria-hidden=true href=#격리수준-설정방법>#</a></h3><blockquote><ol><li>전역 설정</li></ol></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>GLOBAL</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>REPEATABLE</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><ol start=2><li>세션설정</li></ol></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><ol start=3><li>트랜잭션 시작시 설정하기</li></ol></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>SERIALIZABLE</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=mvccmulti-version-concurrency-control>MVCC(Multi-Version-Concurrency Control)<a hidden class=anchor aria-hidden=true href=#mvccmulti-version-concurrency-control>#</a></h3><ul><li>참고: <a href="https://www.youtube.com/watch?v=8OFTB57G9IU&amp;t=1294s">12가지 디자인패턴으로 알아보는 클라우드 네이티브 마이크로서비스 아키텍쳐 - 김형일, 박진현 / AWS Summit Seoul 2023</a></li></ul><hr><h1 id=인덱스index>인덱스(Index)<a hidden class=anchor aria-hidden=true href=#인덱스index>#</a></h1><p><img alt=book-index-example loading=lazy src=../images/book-index-example.png></p><ul><li>위의 예시처럼 책의 목차를 보면, 각 목차별로 페이지를 기재해준다.</li><li>검색속도 향상을 위해서 데이터(data row)를 식별가능하도록 저장하는 객체이다.</li><li>검색속도 향상으로 데이터베이스 부하 감소를 목적으로 한다.</li></ul><h2 id=인덱스-개념>인덱스 개념<a hidden class=anchor aria-hidden=true href=#인덱스-개념>#</a></h2><ul><li>특정 컬럼으로 인덱스를 설정하면, 해당 컬럼의 값을 정렬하여 데이터를 적재해두어 해당 컬럼의 조회 성능을 향상시킨다.<ul><li>1~100까지의 수를 랜덤하게 펼쳐두고 30보다 작은 값을 찾는다.</li><li>1~100까지의 수를 오름차순으로 정렬하고 30보다 작은 값을 찾는다.</li></ul></li><li>인덱스는 조회성능을 높일 수 있지만 아래 사항을 고려하여 설계해야한다.<ul><li><strong>한번에 찾을 수 있는 값인가?</strong> - 데이터 중복이 적은 컬럼</li><li><strong>인덱스 재정렬을 최소화할 수 있는가?</strong> - 데이터 삽입, 수정이 적은 컬럼.</li><li><strong>인덱스의 목적은 검색이다</strong> - 조회에 자주사용되는 컬럼</li><li><strong>너무 많지 않은 인덱스</strong> - 인덱스도 별도의 공간을 차지.<ul><li>인덱스도 공간을 차지하기 때문에 너무 많이 있어도 문제가 생긴다.</li><li>인덱스 조정때문에 쓰기연산인 데이터 삽입/수정/삭제 연산 성능이 하락될 수 있다.</li></ul></li></ul></li></ul><h3 id=그럼-인덱스는-언제-필요할까>그럼 인덱스는 언제 필요할까?<a hidden class=anchor aria-hidden=true href=#그럼-인덱스는-언제-필요할까>#</a></h3><ul><li>데이터가 너무 많아서 조건에 부합하는 결과데이터를 찾는데 오래걸릴 경우</li></ul><h2 id=단일-인덱스>단일 인덱스<a hidden class=anchor aria-hidden=true href=#단일-인덱스>#</a></h2><ul><li>1개 컬럼으로 구성된 인덱스</li></ul><h2 id=복합-인덱스>복합 인덱스<a hidden class=anchor aria-hidden=true href=#복합-인덱스>#</a></h2><ul><li>2개이상의 컬럼으로 구성된 인덱스</li><li>카디널리티가 높은 컬럼순으로 구성해야 검색속도를 높일 수 있다.</li><li>인덱스의 컬럼 순서와 조건 조회 순서가 일치하지 않으면 인덱스를 이용하지 않는다.</li></ul><h2 id=covering-인덱스>Covering 인덱스<a hidden class=anchor aria-hidden=true href=#covering-인덱스>#</a></h2><ul><li>특정 쿼리를 충족시키는데 필요한 모든 데이터를 포함하는 인덱스</li><li>모든컬럼의 조회대상, 조회 조건에 포함된다면 데이터를 찾기위해서 Row에 접근할 필요가 없으므로, 인덱스 스캔만 발생하므로 높은 조회 성능을 가진다.</li></ul><h3 id=카디널리티cardinality>카디널리티(Cardinality)<a hidden class=anchor aria-hidden=true href=#카디널리티cardinality>#</a></h3><ul><li>정의: 테이블의 열(column)이 가지는 고유한 값의 개수를 의미한다.</li></ul><table><thead><tr><th style=text-align:center>ID</th><th style=text-align:center>GENDER</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>M</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>M</td></tr></tbody></table><blockquote><ul><li>gender 컬럼의 카디널리티개수: 2개 (M/F)</li><li>ID 컬럼의 카디널리티개수: 5개 (모두 고유하다)</li></ul></blockquote><ul><li><p>종류</p><ul><li>높은 카디널리티: 고유값이 많은 컬럼<ul><li>예) 주민등록번호, 이메일, 고유 PK 식별자 ID</li></ul></li><li>중간 카디널리티: 값이 적당히 중복되는 컬럼<ul><li>예) 우편번호, 도시이름, 이름</li></ul></li><li>낮은 카디널리티: 값이 거의 중복되는 컬럼<ul><li>예) 성별(M/F), 국가(대한민국)</li></ul></li></ul></li><li><p>카디널리티와 인덱스의 연관관계</p><ul><li>카디널리티가 높을수록 인덱스 성능이 좋다. 왜냐하면 인덱스를 통해서 많은 데이터를 빠르게 걸러낼 수 있기 때문이다.</li><li>카디널리티가 낮을수록 컬럼에 인덱스를 걸게되면 인덱스보다는 테이블 풀스캔이 더 효율적일 수 있다.</li></ul></li><li><p>관계형 모델에서의 카디널리티(엔티티 관계)</p><ul><li>1:1</li><li>1:N</li><li>N:M</li></ul></li></ul><h2 id=sync-schedule-strategy>Sync Schedule Strategy<a hidden class=anchor aria-hidden=true href=#sync-schedule-strategy>#</a></h2><ul><li><p>통계 데이터를 활용하는 방법이다.</p></li><li><p>실시간성과 정합성의 Trade-Off 를 극복하기위해서 데이터베이스 I/O를 줄이고 언젠간 정합성이 맞아 떨어지는 환경을 구성하는 전략이다.</p></li><li><p>자주 삽입/수정하는 데이터에 대해서 인덱스를 적용하게되면 인덱스의 재조정으로 인해서 성능이 하락될 수 있다. 인덱스도 공간을 차지할 수 있으므로, 인덱스를 통해서 읽어야할 데이터레코드가 전체데이터베이스에서 20~25% 넘게 차지한다면 인덱스로 읽기보다는 테이블의 데이터를 직접 읽는 것이 더 효율적이다.</p></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://loveAlakazam.github.io/blog/docs/upgrade-architect/><span class=title>Next »</span><br><span>아키텍쳐 고민하기</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://loveAlakazam.github.io/blog/>EK Dev Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>