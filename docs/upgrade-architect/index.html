<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>아키텍쳐 고민하기 | EK Dev Blog</title>
<meta name=keywords content><meta name=description content="ERD 개선하기 보완피드백1: 유저와 토큰 테이블 분리하기
보완피드백2: 테이블의 역할을 고민해서 만들기
payments 라는 엔티티에 금액정보가 없어서 책임을 다하지 못할 수 있음.
As-Is (1차 설계) To-Be (2차 설계) 테이블개수를 6개 -> 8개 로 확장했습니다. 토큰(tokens) 테이블 추가 포인트 내역(point_histories) 테이블 추가 payments 테이블에 결제금액(price) 를 추가하여 결제에 대한 책임을 부여했습니다. 2차 설계안 고민포인트 1번을 참고하여, 날짜에서 예약가능여부(is_available)을 추가했습니다. ERD 2차 설계안 고민포인트 대기열토큰의 대기순서를 나타내려면, 토큰테이블에 대기순서를 기재하는게 좋을까요 아니면 대기열큐를 하나의 테이블로 나타내어 대기순서를 기재하는게 좋을까요?"><meta name=author content><link rel=canonical href=https://loveAlakazam.github.io/blog/docs/upgrade-architect/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://loveAlakazam.github.io/blog/docs/upgrade-architect/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://loveAlakazam.github.io/blog/docs/upgrade-architect/"><meta property="og:site_name" content="EK Dev Blog"><meta property="og:title" content="아키텍쳐 고민하기"><meta property="og:description" content="ERD 개선하기 보완피드백1: 유저와 토큰 테이블 분리하기
보완피드백2: 테이블의 역할을 고민해서 만들기
payments 라는 엔티티에 금액정보가 없어서 책임을 다하지 못할 수 있음.
As-Is (1차 설계) To-Be (2차 설계) 테이블개수를 6개 -> 8개 로 확장했습니다. 토큰(tokens) 테이블 추가 포인트 내역(point_histories) 테이블 추가 payments 테이블에 결제금액(price) 를 추가하여 결제에 대한 책임을 부여했습니다. 2차 설계안 고민포인트 1번을 참고하여, 날짜에서 예약가능여부(is_available)을 추가했습니다. ERD 2차 설계안 고민포인트 대기열토큰의 대기순서를 나타내려면, 토큰테이블에 대기순서를 기재하는게 좋을까요 아니면 대기열큐를 하나의 테이블로 나타내어 대기순서를 기재하는게 좋을까요?"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-04-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="아키텍쳐 고민하기"><meta name=twitter:description content="ERD 개선하기 보완피드백1: 유저와 토큰 테이블 분리하기
보완피드백2: 테이블의 역할을 고민해서 만들기
payments 라는 엔티티에 금액정보가 없어서 책임을 다하지 못할 수 있음.
As-Is (1차 설계) To-Be (2차 설계) 테이블개수를 6개 -> 8개 로 확장했습니다. 토큰(tokens) 테이블 추가 포인트 내역(point_histories) 테이블 추가 payments 테이블에 결제금액(price) 를 추가하여 결제에 대한 책임을 부여했습니다. 2차 설계안 고민포인트 1번을 참고하여, 날짜에서 예약가능여부(is_available)을 추가했습니다. ERD 2차 설계안 고민포인트 대기열토큰의 대기순서를 나타내려면, 토큰테이블에 대기순서를 기재하는게 좋을까요 아니면 대기열큐를 하나의 테이블로 나타내어 대기순서를 기재하는게 좋을까요?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://loveAlakazam.github.io/blog/docs/"},{"@type":"ListItem","position":2,"name":"아키텍쳐 고민하기","item":"https://loveAlakazam.github.io/blog/docs/upgrade-architect/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"아키텍쳐 고민하기","name":"아키텍쳐 고민하기","description":"ERD 개선하기 보완피드백1: 유저와 토큰 테이블 분리하기\n보완피드백2: 테이블의 역할을 고민해서 만들기\npayments 라는 엔티티에 금액정보가 없어서 책임을 다하지 못할 수 있음.\nAs-Is (1차 설계) To-Be (2차 설계) 테이블개수를 6개 -\u0026gt; 8개 로 확장했습니다. 토큰(tokens) 테이블 추가 포인트 내역(point_histories) 테이블 추가 payments 테이블에 결제금액(price) 를 추가하여 결제에 대한 책임을 부여했습니다. 2차 설계안 고민포인트 1번을 참고하여, 날짜에서 예약가능여부(is_available)을 추가했습니다. ERD 2차 설계안 고민포인트 대기열토큰의 대기순서를 나타내려면, 토큰테이블에 대기순서를 기재하는게 좋을까요 아니면 대기열큐를 하나의 테이블로 나타내어 대기순서를 기재하는게 좋을까요?","keywords":[],"articleBody":"ERD 개선하기 보완피드백1: 유저와 토큰 테이블 분리하기\n보완피드백2: 테이블의 역할을 고민해서 만들기\npayments 라는 엔티티에 금액정보가 없어서 책임을 다하지 못할 수 있음.\nAs-Is (1차 설계) To-Be (2차 설계) 테이블개수를 6개 -\u003e 8개 로 확장했습니다. 토큰(tokens) 테이블 추가 포인트 내역(point_histories) 테이블 추가 payments 테이블에 결제금액(price) 를 추가하여 결제에 대한 책임을 부여했습니다. 2차 설계안 고민포인트 1번을 참고하여, 날짜에서 예약가능여부(is_available)을 추가했습니다. ERD 2차 설계안 고민포인트 대기열토큰의 대기순서를 나타내려면, 토큰테이블에 대기순서를 기재하는게 좋을까요 아니면 대기열큐를 하나의 테이블로 나타내어 대기순서를 기재하는게 좋을까요? 멀티스레드의 동시성을 고려하게될텐데 여기서는 대기열이 동시성을 담당하는거 같습니다. 계속 대기열도 테이블로 나타내려고하는데 아직도 혼란이 남은거같아 질문을 드립니다.\n좌석예약 뿐만 아니라 날짜예약이 가능 여부에 대한 고려가 필요한거 같습니다. 이전에는 좌석의 예약 가능여부만 생각해왔습니다. 좌석예약하기전 날짜 선택도 예약 가능여부를 고려하는 것을 놓쳤습니다. 콘서트에서 예약가능한 날짜를 선택할 때 고려사항 2가지가 있습니다.\n(고려사항 1) 콘서트의 예약가능한 날짜목록은 현재를 기준으로 현재~미래 날짜인지?\n예약가능한 날짜가 현재기준으로 과거날짜면 이미 종료됐으므로 예약불가능 을 나타내야합니다.\n(고려사항 2) 예약가능한 날짜에서 이미 좌석이 만석됐을 경우\n(고려사항 1)의 경우에는 매일 0시에 배치 스케줄러로 상태값을 ‘예약불가능’(is_available = false)으로 변경이 필요할거 같습니다. (고려사항 2)의 경우에도 좌석이 예약가능한 날짜의 예약좌석수가 만석인지 아닌지를 확인하고 만석이라면 ‘예약불가능’(is_available = false) 으로 상태값을 변경해야하며 실시간으로 상태값 변경을 나타낼 필요가 있습니다.\n(고려사항1)과 (고려사항2)를 고려해보면 스케줄러 2개를 추가해야될거 같습니다. 실제라면 예약가능한 날짜도 예약가능한지 아닌지 실시간으로 공유가 필요해보이지만 제가 오버엔지니어링을 한게 아닌가 의문이 들기도합니다.\n설계를 하면서 깨달은 설계에 대한 나의 철학 Seat 테이블에 왜 price 컬럼이 있나요? 콘서트나 뮤지컬 연극의 경우에는 좌석에 따라 가격이 다르기 때문입니다. 영화관의경우에는 좌석별 자리보다는 영화관이 어떤 장소냐(4DX, 일반 2D, 3D 등)에 따라 가격이 다른편입니다. 실제 사례를 봤을때 콘서트의 경우에는 영화관처럼 모든 좌석의 가격을 동일하게 하는 것보다는 좌석마다 가격을 다르게하는 방안으로 선택했습니다.\n3차 ERD 설계안 2차 ERD를 바탕으로 테이블 엔티티를 구현하려던중 엔티티를 한번더 검증을 해봤습니다. 구현하면서 ‘내가 테이블의 역할에 대한 이해를 하고있나?’ 라는 의문점이 들었습니다. 그래서 한번더 재검증을 위해서 한번더 테이블간의 연관관계(Cardinality)를 검증해봤습니다.\n2차에서 예약과 유저간의 관계, 예약과 콘서트/콘서트 날짜/콘서트 좌석 테이블간의 관계를 정리해보는 시도를 해봤습니다. 예약테이블과의 연관 카디널리티를 변경하였습니다.\n(AS-IS)\n예약:유저 = 1:1\n예약:콘서트 = 1:1\n예약:콘서트 날짜 = 1:1\n예약:콘서트 좌석 = 1:1\n(TO-BE)\n예약:유저 = 1:N\n예약:콘서트 = N:1\n예약:콘서트 날짜 = N:1\n예약:콘서트 좌석 = 1:1\n시퀀스 다이어그램 보완피드백 1: 비즈니스 로직의 이해를 높이고자 시퀀스 다이어그램에서 적절한 상태임을 가정하는 케이스가 많은데, 핵심 예외에 대해서는 시퀀스 다이어그램에 표현\n보완피드백 2: 좌석예약 요청 API에서 예약서비스에 콘서트 좌석의 상태 확인을 요청하는데 예약서비스에서 해당 구현이 가능한지 다시 생각해보기.\nHugo 블로그의 코드포맷팅에서 Mermaid.js를 지원하지 않기때문에 자세한 시퀀스다이어그램은 2차 시퀀스 다이어그램 위키문서에 기재했습니다.\n플로우차트 보완피드백 1: 전체적인 흐름은 시퀀스다이어그램보다 플로우차트로 나타내기\n느낀점 설계는 고민을 많이 해야되고 해당 서비스에 대해 시간을 많이 투자가 필요하다는 걸 깨달았습니다.\n무엇보다도 설계를 하기전에 서비스에 대한 이해가 필요하다는걸, 1차설계에는 기한내에 과제제출에 급해서 서비스에 대한 이해와 고민을 깊게하지 못했다는 생각이 들었습니다. 다른사람들보다 설계에 시간을 투자하지 못했지만 지금이라도 API를 코드로 구현하기전에 명확한 설계를 만들어보고 싶었습니다.\n설계에 대한 날카로운 피드백을 주셨는데 제게 많이 도움이 됐습니다. 아직도 부족함을 느끼지만, 그래도 피드백을 주시면 감사하겠습니다. 긴글을 읽어주셔서 감사합니다.\n제가 설계문서를 작성한 위키문서 링크를 공유드리며 이글을 마치겠습니다.\n설계 위키문서 링크: 콘서트 API 설계관련 위키문서 ","wordCount":"478","inLanguage":"en","datePublished":"2025-04-05T00:00:00Z","dateModified":"2025-04-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://loveAlakazam.github.io/blog/docs/upgrade-architect/"},"publisher":{"@type":"Organization","name":"EK Dev Blog","logo":{"@type":"ImageObject","url":"https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loveAlakazam.github.io/blog/ accesskey=h title="EK Dev Blog (Alt + H)"><img src=https://loveAlakazam.github.io/apple-touch-icon.png alt aria-label=logo height=35>EK Dev Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eunkangchoi.github.io/resume/ title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loveAlakazam.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://loveAlakazam.github.io/blog/docs/>Docs</a></div><h1 class="post-title entry-hint-parent">아키텍쳐 고민하기</h1><div class=post-meta><span title='2025-04-05 00:00:00 +0000 UTC'>April 5, 2025</span></div></header><div class=post-content><h2 id=erd-개선하기>ERD 개선하기<a hidden class=anchor aria-hidden=true href=#erd-개선하기>#</a></h2><blockquote><ul><li><p>보완피드백1: 유저와 토큰 테이블 분리하기</p></li><li><p>보완피드백2: 테이블의 역할을 고민해서 만들기</p><p>payments 라는 엔티티에 금액정보가 없어서 책임을 다하지 못할 수 있음.</p></li></ul></blockquote><h3 id=as-is-1차-설계>As-Is (1차 설계)<a hidden class=anchor aria-hidden=true href=#as-is-1차-설계>#</a></h3><p><img alt=hh-concert-erd-ver01 loading=lazy src=../images/hh-concert-erd-ver01.png></p><h3 id=to-be-2차-설계>To-Be (2차 설계)<a hidden class=anchor aria-hidden=true href=#to-be-2차-설계>#</a></h3><ul><li>테이블개수를 6개 -> 8개 로 확장했습니다.<ul><li>토큰(tokens) 테이블 추가</li><li>포인트 내역(point_histories) 테이블 추가</li></ul></li><li>payments 테이블에 결제금액(price) 를 추가하여 결제에 대한 책임을 부여했습니다.</li><li>2차 설계안 고민포인트 1번을 참고하여, 날짜에서 예약가능여부(is_available)을 추가했습니다.</li></ul><p><img alt=hh-concert-erd-ver02 loading=lazy src=../images/hh-concert-erd-ver02.png></p><h3 id=erd-2차-설계안-고민포인트>ERD 2차 설계안 고민포인트<a hidden class=anchor aria-hidden=true href=#erd-2차-설계안-고민포인트>#</a></h3><ol><li>대기열토큰의 대기순서를 나타내려면, 토큰테이블에 대기순서를 기재하는게 좋을까요 아니면 대기열큐를 하나의 테이블로 나타내어 대기순서를 기재하는게 좋을까요?</li></ol><p>멀티스레드의 동시성을 고려하게될텐데 여기서는 대기열이 동시성을 담당하는거 같습니다. 계속 대기열도 테이블로 나타내려고하는데 아직도 혼란이 남은거같아 질문을 드립니다.</p><ol start=2><li>좌석예약 뿐만 아니라 날짜예약이 가능 여부에 대한 고려가 필요한거 같습니다.</li></ol><p>이전에는 좌석의 예약 가능여부만 생각해왔습니다. 좌석예약하기전 날짜 선택도 예약 가능여부를 고려하는 것을 놓쳤습니다. 콘서트에서 예약가능한 날짜를 선택할 때 고려사항 2가지가 있습니다.</p><blockquote><ul><li><p>(고려사항 1) 콘서트의 예약가능한 날짜목록은 현재를 기준으로 현재~미래 날짜인지?</p><p>예약가능한 날짜가 현재기준으로 과거날짜면 이미 종료됐으므로 예약불가능 을 나타내야합니다.</p></li><li><p>(고려사항 2) 예약가능한 날짜에서 이미 좌석이 만석됐을 경우</p></li></ul></blockquote><p>(고려사항 1)의 경우에는 매일 0시에 배치 스케줄러로 상태값을 &lsquo;예약불가능&rsquo;(<code>is_available = false</code>)으로 변경이 필요할거 같습니다.
<img alt=ticket-terminated-example loading=lazy src=../images/ticket-terminated-example.png></p><p>(고려사항 2)의 경우에도 좌석이 예약가능한 날짜의 예약좌석수가 만석인지 아닌지를 확인하고 만석이라면 &lsquo;예약불가능&rsquo;(<code>is_available = false</code>) 으로 상태값을 변경해야하며 실시간으로 상태값 변경을 나타낼 필요가 있습니다.</p><p><img alt=ticket-soldout-example loading=lazy src=../images/ticket-soldout-example.png></p><p>(고려사항1)과 (고려사항2)를 고려해보면 스케줄러 2개를 추가해야될거 같습니다.
실제라면 예약가능한 날짜도 예약가능한지 아닌지 실시간으로 공유가 필요해보이지만 제가 오버엔지니어링을 한게 아닌가 의문이 들기도합니다.</p><h3 id=설계를-하면서-깨달은-설계에-대한-나의-철학>설계를 하면서 깨달은 설계에 대한 나의 철학<a hidden class=anchor aria-hidden=true href=#설계를-하면서-깨달은-설계에-대한-나의-철학>#</a></h3><ol><li>Seat 테이블에 왜 price 컬럼이 있나요?</li></ol><p>콘서트나 뮤지컬 연극의 경우에는 좌석에 따라 가격이 다르기 때문입니다. 영화관의경우에는 좌석별 자리보다는 영화관이 어떤 장소냐(4DX, 일반 2D, 3D 등)에 따라 가격이 다른편입니다. 실제 사례를 봤을때 콘서트의 경우에는 영화관처럼 모든 좌석의 가격을 동일하게 하는 것보다는 좌석마다 가격을 다르게하는 방안으로 선택했습니다.</p><h3 id=3차-erd-설계안>3차 ERD 설계안<a hidden class=anchor aria-hidden=true href=#3차-erd-설계안>#</a></h3><p><img alt=erd-ver-3 loading=lazy src=../images/erd-ver-3.png></p><p>2차 ERD를 바탕으로 테이블 엔티티를 구현하려던중 엔티티를 한번더 검증을 해봤습니다. 구현하면서 &lsquo;내가 테이블의 역할에 대한 이해를 하고있나?&rsquo; 라는 의문점이 들었습니다. 그래서 한번더 재검증을 위해서 한번더 테이블간의 연관관계(Cardinality)를 검증해봤습니다.</p><p>2차에서 예약과 유저간의 관계, 예약과 콘서트/콘서트 날짜/콘서트 좌석 테이블간의 관계를 정리해보는 시도를 해봤습니다. 예약테이블과의 연관 카디널리티를 변경하였습니다.</p><blockquote><p>(AS-IS)</p></blockquote><ul><li><p>예약:유저 = 1:1</p></li><li><p>예약:콘서트 = 1:1</p></li><li><p>예약:콘서트 날짜 = 1:1</p></li><li><p>예약:콘서트 좌석 = 1:1</p><blockquote><p>(TO-BE)</p></blockquote></li><li><p>예약:유저 = 1:N</p></li><li><p>예약:콘서트 = N:1</p></li><li><p>예약:콘서트 날짜 = N:1</p></li><li><p>예약:콘서트 좌석 = 1:1</p></li></ul><p><img alt=erd-v3-reservation-cardinality loading=lazy src=../images/erd-v3-reservation-cardinality.png></p><hr><h2 id=시퀀스-다이어그램>시퀀스 다이어그램<a hidden class=anchor aria-hidden=true href=#시퀀스-다이어그램>#</a></h2><blockquote><p>보완피드백 1: 비즈니스 로직의 이해를 높이고자 시퀀스 다이어그램에서 적절한 상태임을 가정하는 케이스가 많은데, 핵심 예외에 대해서는 시퀀스 다이어그램에 표현</p><p>보완피드백 2: 좌석예약 요청 API에서 예약서비스에 콘서트 좌석의 상태 확인을 요청하는데 예약서비스에서 해당 구현이 가능한지 다시 생각해보기.</p></blockquote><p>Hugo 블로그의 코드포맷팅에서 Mermaid.js를 지원하지 않기때문에 자세한 시퀀스다이어그램은 <a href=https://github.com/loveAlakazam/hh-08-concert/wiki/03_%EC%8B%9C%ED%80%80%EC%8A%A4%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8_2nd>2차 시퀀스 다이어그램 위키문서</a>에 기재했습니다.</p><hr><h2 id=플로우차트>플로우차트<a hidden class=anchor aria-hidden=true href=#플로우차트>#</a></h2><blockquote><p>보완피드백 1: 전체적인 흐름은 시퀀스다이어그램보다 플로우차트로 나타내기</p></blockquote><p><img alt=full-flow-chart loading=lazy src=../images/full-flow-chart.png></p><hr><h2 id=느낀점>느낀점<a hidden class=anchor aria-hidden=true href=#느낀점>#</a></h2><p>설계는 고민을 많이 해야되고 해당 서비스에 대해 시간을 많이 투자가 필요하다는 걸 깨달았습니다.</p><p>무엇보다도 설계를 하기전에 서비스에 대한 이해가 필요하다는걸, 1차설계에는 기한내에 과제제출에 급해서 서비스에 대한 이해와 고민을 깊게하지 못했다는 생각이 들었습니다.
다른사람들보다 설계에 시간을 투자하지 못했지만 지금이라도 API를 코드로 구현하기전에 명확한 설계를 만들어보고 싶었습니다.</p><p>설계에 대한 날카로운 피드백을 주셨는데 제게 많이 도움이 됐습니다.
아직도 부족함을 느끼지만, 그래도 피드백을 주시면 감사하겠습니다. 긴글을 읽어주셔서 감사합니다.</p><p>제가 설계문서를 작성한 위키문서 링크를 공유드리며 이글을 마치겠습니다.</p><ul><li>설계 위키문서 링크: <a href=https://github.com/loveAlakazam/hh-08-concert/wiki>콘서트 API 설계관련 위키문서</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://loveAlakazam.github.io/blog/docs/factory-methods/><span class=title>« Prev</span><br><span>정적 팩토리 메소드</span>
</a><a class=next href=https://loveAlakazam.github.io/blog/docs/hh-08-week02-remind/><span class=title>Next »</span><br><span>항해99 2주차 회고 (WIL)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://loveAlakazam.github.io/blog/>EK Dev Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>