<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>항해99 6주차 회고(WIL) | EK Dev Blog</title>
<meta name=keywords content><meta name=description content="Q. 인상깊었던 주제는 무엇이었나요? 분산락과 캐시 전략중 어떤 주제가 더 인상깊었나요?
항해를 하기전 레디스를 사용해왔을때는 JWT 토큰정도로만 해왔습니다. Key value 기반 NoSQL 데이터베이스인 레디스가 단순히 캐싱의 역할을 하지 않고 Lock으로서의 역할을 할 수 있다는걸 이번과제를 통해 새로알게됐습니다. 또한 읽기와 쓰기에서의 캐싱전략이 여러가지가 있다는걸 처음알게됐습니다.
해당 개념을 통해 어떤 구조적/성능적 문제 해결을 가능성을 느꼈나요?
아직까지는 과제를 수행해보면서 어느점이 문제인지, 그에 대한 해결은 무엇인지에 대한 답변이 명확하지 않았습니다. 그래도 떠오르는 한가지는 캐싱쪽에서는 트랜잭션을 접근하기전에 캐시저장소(redis)에서 캐시히트가되면 빠른 응답을 해줄 수 있다는 점입니다."><meta name=author content><link rel=canonical href=https://loveAlakazam.github.io/blog/docs/hh-08-week06-remind/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://loveAlakazam.github.io/blog/docs/hh-08-week06-remind/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://loveAlakazam.github.io/blog/docs/hh-08-week06-remind/"><meta property="og:site_name" content="EK Dev Blog"><meta property="og:title" content="항해99 6주차 회고(WIL)"><meta property="og:description" content="Q. 인상깊었던 주제는 무엇이었나요? 분산락과 캐시 전략중 어떤 주제가 더 인상깊었나요?
항해를 하기전 레디스를 사용해왔을때는 JWT 토큰정도로만 해왔습니다. Key value 기반 NoSQL 데이터베이스인 레디스가 단순히 캐싱의 역할을 하지 않고 Lock으로서의 역할을 할 수 있다는걸 이번과제를 통해 새로알게됐습니다. 또한 읽기와 쓰기에서의 캐싱전략이 여러가지가 있다는걸 처음알게됐습니다.
해당 개념을 통해 어떤 구조적/성능적 문제 해결을 가능성을 느꼈나요?
아직까지는 과제를 수행해보면서 어느점이 문제인지, 그에 대한 해결은 무엇인지에 대한 답변이 명확하지 않았습니다. 그래도 떠오르는 한가지는 캐싱쪽에서는 트랜잭션을 접근하기전에 캐시저장소(redis)에서 캐시히트가되면 빠른 응답을 해줄 수 있다는 점입니다."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-05-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="항해99 6주차 회고(WIL)"><meta name=twitter:description content="Q. 인상깊었던 주제는 무엇이었나요? 분산락과 캐시 전략중 어떤 주제가 더 인상깊었나요?
항해를 하기전 레디스를 사용해왔을때는 JWT 토큰정도로만 해왔습니다. Key value 기반 NoSQL 데이터베이스인 레디스가 단순히 캐싱의 역할을 하지 않고 Lock으로서의 역할을 할 수 있다는걸 이번과제를 통해 새로알게됐습니다. 또한 읽기와 쓰기에서의 캐싱전략이 여러가지가 있다는걸 처음알게됐습니다.
해당 개념을 통해 어떤 구조적/성능적 문제 해결을 가능성을 느꼈나요?
아직까지는 과제를 수행해보면서 어느점이 문제인지, 그에 대한 해결은 무엇인지에 대한 답변이 명확하지 않았습니다. 그래도 떠오르는 한가지는 캐싱쪽에서는 트랜잭션을 접근하기전에 캐시저장소(redis)에서 캐시히트가되면 빠른 응답을 해줄 수 있다는 점입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://loveAlakazam.github.io/blog/docs/"},{"@type":"ListItem","position":2,"name":"항해99 6주차 회고(WIL)","item":"https://loveAlakazam.github.io/blog/docs/hh-08-week06-remind/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"항해99 6주차 회고(WIL)","name":"항해99 6주차 회고(WIL)","description":"Q. 인상깊었던 주제는 무엇이었나요? 분산락과 캐시 전략중 어떤 주제가 더 인상깊었나요?\n항해를 하기전 레디스를 사용해왔을때는 JWT 토큰정도로만 해왔습니다. Key value 기반 NoSQL 데이터베이스인 레디스가 단순히 캐싱의 역할을 하지 않고 Lock으로서의 역할을 할 수 있다는걸 이번과제를 통해 새로알게됐습니다. 또한 읽기와 쓰기에서의 캐싱전략이 여러가지가 있다는걸 처음알게됐습니다.\n해당 개념을 통해 어떤 구조적/성능적 문제 해결을 가능성을 느꼈나요?\n아직까지는 과제를 수행해보면서 어느점이 문제인지, 그에 대한 해결은 무엇인지에 대한 답변이 명확하지 않았습니다. 그래도 떠오르는 한가지는 캐싱쪽에서는 트랜잭션을 접근하기전에 캐시저장소(redis)에서 캐시히트가되면 빠른 응답을 해줄 수 있다는 점입니다.","keywords":[],"articleBody":"Q. 인상깊었던 주제는 무엇이었나요? 분산락과 캐시 전략중 어떤 주제가 더 인상깊었나요?\n항해를 하기전 레디스를 사용해왔을때는 JWT 토큰정도로만 해왔습니다. Key value 기반 NoSQL 데이터베이스인 레디스가 단순히 캐싱의 역할을 하지 않고 Lock으로서의 역할을 할 수 있다는걸 이번과제를 통해 새로알게됐습니다. 또한 읽기와 쓰기에서의 캐싱전략이 여러가지가 있다는걸 처음알게됐습니다.\n해당 개념을 통해 어떤 구조적/성능적 문제 해결을 가능성을 느꼈나요?\n아직까지는 과제를 수행해보면서 어느점이 문제인지, 그에 대한 해결은 무엇인지에 대한 답변이 명확하지 않았습니다. 그래도 떠오르는 한가지는 캐싱쪽에서는 트랜잭션을 접근하기전에 캐시저장소(redis)에서 캐시히트가되면 빠른 응답을 해줄 수 있다는 점입니다.\nQ. Race condition, Deadlock, Cache Stampede 등 방어할 포인트는 어떻게 설계하나요? Race condition \u0026 Deadlock 분산락을 도입하기전에 동시에 좌석예약을 할경우에는 낙관적락을 사용하여 빠른 실패를 나타내어 해결을했습니다. 그러므로 낙관적락은 논리적락으로써 Race condition, DeadLock 문제는 자연스레 해결이 됐습니다.\n포인트 충전/사용 의 경우에는 배타락을 사용하였습니다. 동시요청이 들어와도 포인트라는 공유자원에 대한 데이터의 정합성을 우선으로 하였기때문에 비관적락이자 물리적락인 x-lock을 사용했습니다. 유저포인트라는 공유자원을 동시에 요청할때 락을 획득하지 않은 다른 트랜잭션들은 읽기/쓰기 접근을 하지못하도록 막습니다.\n솔직히 기존의 락으로도 Race condition이나 dead-lock을 막을 수 있다고 생각합니다.\nCache stampede 이에 대한 방어포인트는 데이터의 변경이 자주 일어나는지? 데이터의 변경이 드문지를 파악해야될거 같다고 생각합니다.\nQ. 여러 캐싱방식과 락 구현방법중 어떤것을 왜 선택했는지 설명해주세요. 분산락 구현 계획과 그이유 사용 기능 사용 분산락 사유 TTL 좌석 임시예약 심플락 재시도횟수가 필요없으며, 동일한좌석에 대해 동시접근할때 1명을 제외한 나머지는 빠른실패를 비롯한 즉각적인 응답을 나타내야하기때문입니다. 5분 포인트 사용 \u0026 충전 스핀락 포인트(공유자원)에 대한 접근을 배타락으로 보호하여 동시요청이 오더라도 데이터정합성을 지키기위해서 동시에 충전/사용이 처리가 됩니다. 동시에 접근을 차단해주며, 다시 시도하여 순차적으로 처리하여 데이터의 정합성까지 지키기위해서 스핀락을 사용하기로 했습니다. 락을 점유할 수 있는 최대시간은 5초이며, 락 획득을 위해 다른 스레드가 기다릴 수 있는 최대시간은 5초입니다. 락을 얻기위해 다시 시도를 하기위한 시간은 100ms 로 설정했습니다. 5초 캐싱방식 구현 계획과 그이유 사용 기능 선택전략 사유 TTL 콘서트목록 읽기전략 현재를 기준으로 예약가능한 목록리스트를 불러오기위함입니다. 60분 콘서트일정 목록 읽기전략 현재를 기준으로 예약가능한 콘서트 일정목록을 나타내며 concertSeat, concert테이블을 조인하기때문입니다. 30분 콘서트좌석목록 읽기전략 좌석상태(예약확정, 임시예약, 예약가능)를 확인하기 위함입니다. 상시변경가능성이 높기때문에 TTL고려가 필요 5분 토큰발급 쓰기전략 토큰상태 상관없이 토큰의 유효시간은 5분이기때문에 토큰의 유효성을 나타내기위함입니다 5분 좌석 임시예약 쓰기전략 좌석상태가 변경되기때문에 캐시저장소와 데이터베이스에 저장된 데이터가 일치하도록 정합성을 지켜야합니다. 예를들어 데이터의 정합성이 어긋나버리면 좌석이 이미 임시예약상태인데 클라이언트입장에서는 예약가능하다고하면 UX상에서도 불편함을 초래할 수 있기때문입니다. 5분 좌석 임시예약 취소 쓰기 전략 임시예약의 유효시간(5분)이 지났기때문에 스케줄러에 의해 취소처리가됩니다. 취소처리된 좌석은 다시 예약가능한상태이므로, 데이터의 정합성을 위해서 캐시저장소와 데이터베이스에서도 즉시 반영을 해야합니다. 5분 Q. 구현중 어려웠던 점과 고민했던 선택지는 무엇이었나요? 이번과제의 아무래도 분산락과 캐싱전략에 대한 이해. 즉 과제의 요구사항를 이해하는것이 어려웠던것같습니다. 제겐 처음인거 같았고 낯설었습니다. 익숙해지는데 시간이 많이 필요했습니다.\n콘서트시나리오에서는 어느기능에서 어떤 분산락을 써야될지, 어느기능에서 캐싱이 필요한지를 파악하는 것과 각 분산락 기법과 각 캐싱전략에 대한 이해가 필요했습니다. 분산락과 캐싱과의 관계가 있는지 모르는게 투성이었습니다.\n임시예약과 예약취소는 좌석의 상태를 변경이 일어나므로, write-through를 전략으로 콘서트좌석목록을 캐싱하는 방안으로 했습니다. 콘서트좌석목록은 데이터의 변경이 자주일어나서 데이터의 정합성을 지키는게 우선이라고 생각했습니다. write-through 전략의 이론처럼 캐시저장소와 데이터베이스의 동기화시켜 데이터의 정합성을 지키는 쪽으로 구현했습니다.\nQ. 이번주차를 통해 얻은 인사이트는 무엇이었나요? 이번주차를 통해 얻은 인사이트와 다음에 적용할 포인트가 무엇이며, 이번학습을 통해서 성능/동시성 에 대한 어떤 관점이 생겼을까요?\n제가 얻은 인사이트는\n첫번째로는 분산락은 트랜잭션보다 먼저 수행되어야하며, 트랜잭션이 종료후에 락을 해제하므로 트랜잭션보다 나중에 끝난다. 락획득 -\u003e 트랜잭션시작 -\u003e 수행 -\u003e 트랜잭션종료 -\u003e 락해제 분산락은 방어선 역할일뿐, 기존의 RDBMS의 비관적락과 논리락인 낙관적락 등의 대체제는 아니다. 캐싱에는 읽기 전략만 있는게 아니라 쓰기전략도 존재하며, 쓰기전략에는 앞으로 실무프로젝트나 이후 과제에서 “이 전략을 사용해보고싶다” 포인트가 있을까요?\n기존의 락으로 해결하기 어렵고, 분산락만이 해결될 수 있는 상황은 어떤 상황인지에 대해 나만의 언어로 정리해보고 싶습니다.\n프로젝트라기보다는 이 주제에 대해서 조금더 부딪혀보고 조금이라도 더 이해해보고 싶다는 생각이 들었습니다.\n왜 락획득을 트랜잭션접근 이전에 해야될까? 이 순서가 지켜지지 않을때 왜 데이터의 정합성이 깨져버릴까? 에 대한 구체적인 예시를 근거로 만들어내서 나만의 언어로 정리해보고싶습니다.\n이번주차에 연관된 기술이론을 바탕으로 주먹구구식으로 과제에 접목해서 임해왔지만, 성능적인 측면을 개선해보는 조금 더 나아가서 생각해보고 깊게 고민해보고 싶습니다.\n캐싱전략들중 여러개의 전략들이 있는데 직접 구현해보고 그 차이점이 무엇인지 나만의 언어로 정리해보고싶습니다.\n","wordCount":"606","inLanguage":"en","datePublished":"2025-05-10T00:00:00Z","dateModified":"2025-05-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://loveAlakazam.github.io/blog/docs/hh-08-week06-remind/"},"publisher":{"@type":"Organization","name":"EK Dev Blog","logo":{"@type":"ImageObject","url":"https://loveAlakazam.github.io/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loveAlakazam.github.io/blog/ accesskey=h title="EK Dev Blog (Alt + H)"><img src=https://loveAlakazam.github.io/apple-touch-icon.png alt aria-label=logo height=35>EK Dev Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eunkangchoi.github.io/resume/ title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loveAlakazam.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://loveAlakazam.github.io/blog/docs/>Docs</a></div><h1 class="post-title entry-hint-parent">항해99 6주차 회고(WIL)</h1><div class=post-meta><span title='2025-05-10 00:00:00 +0000 UTC'>May 10, 2025</span></div></header><div class=post-content><h2 id=q-인상깊었던-주제는-무엇이었나요>Q. 인상깊었던 주제는 무엇이었나요?<a hidden class=anchor aria-hidden=true href=#q-인상깊었던-주제는-무엇이었나요>#</a></h2><blockquote><p>분산락과 캐시 전략중 어떤 주제가 더 인상깊었나요?</p></blockquote><p>항해를 하기전 레디스를 사용해왔을때는 JWT 토큰정도로만 해왔습니다.
Key value 기반 NoSQL 데이터베이스인 레디스가 단순히 캐싱의 역할을 하지 않고 Lock으로서의 역할을 할 수 있다는걸 이번과제를 통해 새로알게됐습니다. 또한 읽기와 쓰기에서의 캐싱전략이 여러가지가 있다는걸 처음알게됐습니다.</p><blockquote><p>해당 개념을 통해 어떤 구조적/성능적 문제 해결을 가능성을 느꼈나요?</p></blockquote><p>아직까지는 과제를 수행해보면서 어느점이 문제인지, 그에 대한 해결은 무엇인지에 대한 답변이 명확하지 않았습니다.
그래도 떠오르는 한가지는 캐싱쪽에서는 트랜잭션을 접근하기전에 캐시저장소(redis)에서 캐시히트가되면 빠른 응답을 해줄 수 있다는 점입니다.</p><h2 id=q-race-condition-deadlock-cache-stampede-등-방어할-포인트는-어떻게-설계하나요>Q. Race condition, Deadlock, Cache Stampede 등 방어할 포인트는 어떻게 설계하나요?<a hidden class=anchor aria-hidden=true href=#q-race-condition-deadlock-cache-stampede-등-방어할-포인트는-어떻게-설계하나요>#</a></h2><ul><li>Race condition & Deadlock</li></ul><p>분산락을 도입하기전에 동시에 좌석예약을 할경우에는 낙관적락을 사용하여 빠른 실패를 나타내어 해결을했습니다.
그러므로 낙관적락은 논리적락으로써 Race condition, DeadLock 문제는 자연스레 해결이 됐습니다.</p><p>포인트 충전/사용 의 경우에는 배타락을 사용하였습니다. 동시요청이 들어와도 포인트라는 공유자원에 대한 데이터의 정합성을 우선으로 하였기때문에 비관적락이자 물리적락인 x-lock을 사용했습니다. 유저포인트라는 공유자원을 동시에 요청할때 락을 획득하지 않은 다른 트랜잭션들은 읽기/쓰기 접근을 하지못하도록 막습니다.</p><p>솔직히 기존의 락으로도 Race condition이나 dead-lock을 막을 수 있다고 생각합니다.</p><ul><li>Cache stampede</li></ul><p>이에 대한 방어포인트는 데이터의 변경이 자주 일어나는지? 데이터의 변경이 드문지를 파악해야될거 같다고 생각합니다.</p><h2 id=q-여러-캐싱방식과-락-구현방법중-어떤것을-왜-선택했는지-설명해주세요>Q. 여러 캐싱방식과 락 구현방법중 어떤것을 왜 선택했는지 설명해주세요.<a hidden class=anchor aria-hidden=true href=#q-여러-캐싱방식과-락-구현방법중-어떤것을-왜-선택했는지-설명해주세요>#</a></h2><ul><li>분산락 구현 계획과 그이유</li></ul><table><thead><tr><th style=text-align:center>사용 기능</th><th style=text-align:center>사용 분산락</th><th style=text-align:left>사유</th><th style=text-align:center>TTL</th></tr></thead><tbody><tr><td style=text-align:center>좌석 임시예약</td><td style=text-align:center>심플락</td><td style=text-align:left>재시도횟수가 필요없으며, 동일한좌석에 대해 동시접근할때 1명을 제외한 나머지는 빠른실패를 비롯한 즉각적인 응답을 나타내야하기때문입니다.</td><td style=text-align:center>5분</td></tr><tr><td style=text-align:center>포인트 사용 & 충전</td><td style=text-align:center>스핀락</td><td style=text-align:left>포인트(공유자원)에 대한 접근을 배타락으로 보호하여 동시요청이 오더라도 데이터정합성을 지키기위해서 동시에 충전/사용이 처리가 됩니다. 동시에 접근을 차단해주며, 다시 시도하여 순차적으로 처리하여 데이터의 정합성까지 지키기위해서 스핀락을 사용하기로 했습니다. 락을 점유할 수 있는 최대시간은 5초이며, 락 획득을 위해 다른 스레드가 기다릴 수 있는 최대시간은 5초입니다. 락을 얻기위해 다시 시도를 하기위한 시간은 100ms 로 설정했습니다.</td><td style=text-align:center>5초</td></tr></tbody></table><ul><li>캐싱방식 구현 계획과 그이유</li></ul><table><thead><tr><th style=text-align:center>사용 기능</th><th style=text-align:center>선택전략</th><th style=text-align:left>사유</th><th style=text-align:center>TTL</th></tr></thead><tbody><tr><td style=text-align:center>콘서트목록</td><td style=text-align:center>읽기전략</td><td style=text-align:left>현재를 기준으로 예약가능한 목록리스트를 불러오기위함입니다.</td><td style=text-align:center>60분</td></tr><tr><td style=text-align:center>콘서트일정 목록</td><td style=text-align:center>읽기전략</td><td style=text-align:left>현재를 기준으로 예약가능한 콘서트 일정목록을 나타내며 concertSeat, concert테이블을 조인하기때문입니다.</td><td style=text-align:center>30분</td></tr><tr><td style=text-align:center>콘서트좌석목록</td><td style=text-align:center>읽기전략</td><td style=text-align:left>좌석상태(예약확정, 임시예약, 예약가능)를 확인하기 위함입니다. 상시변경가능성이 높기때문에 TTL고려가 필요</td><td style=text-align:center>5분</td></tr><tr><td style=text-align:center>토큰발급</td><td style=text-align:center>쓰기전략</td><td style=text-align:left>토큰상태 상관없이 토큰의 유효시간은 5분이기때문에 토큰의 유효성을 나타내기위함입니다</td><td style=text-align:center>5분</td></tr><tr><td style=text-align:center>좌석 임시예약</td><td style=text-align:center>쓰기전략</td><td style=text-align:left>좌석상태가 변경되기때문에 캐시저장소와 데이터베이스에 저장된 데이터가 일치하도록 정합성을 지켜야합니다. 예를들어 데이터의 정합성이 어긋나버리면 좌석이 이미 임시예약상태인데 클라이언트입장에서는 예약가능하다고하면 UX상에서도 불편함을 초래할 수 있기때문입니다.</td><td style=text-align:center>5분</td></tr><tr><td style=text-align:center>좌석 임시예약 취소</td><td style=text-align:center>쓰기 전략</td><td style=text-align:left>임시예약의 유효시간(5분)이 지났기때문에 스케줄러에 의해 취소처리가됩니다. 취소처리된 좌석은 다시 예약가능한상태이므로, 데이터의 정합성을 위해서 캐시저장소와 데이터베이스에서도 즉시 반영을 해야합니다.</td><td style=text-align:center>5분</td></tr></tbody></table><h2 id=q-구현중-어려웠던-점과-고민했던-선택지는-무엇이었나요>Q. 구현중 어려웠던 점과 고민했던 선택지는 무엇이었나요?<a hidden class=anchor aria-hidden=true href=#q-구현중-어려웠던-점과-고민했던-선택지는-무엇이었나요>#</a></h2><p>이번과제의 아무래도 분산락과 캐싱전략에 대한 이해. 즉 과제의 요구사항를 이해하는것이 어려웠던것같습니다. 제겐 처음인거 같았고 낯설었습니다. 익숙해지는데 시간이 많이 필요했습니다.</p><p>콘서트시나리오에서는 어느기능에서 어떤 분산락을 써야될지, 어느기능에서 캐싱이 필요한지를 파악하는 것과 각 분산락 기법과 각 캐싱전략에 대한 이해가 필요했습니다. 분산락과 캐싱과의 관계가 있는지 모르는게 투성이었습니다.</p><p>임시예약과 예약취소는 좌석의 상태를 변경이 일어나므로, write-through를 전략으로 콘서트좌석목록을 캐싱하는 방안으로 했습니다. 콘서트좌석목록은 데이터의 변경이 자주일어나서 데이터의 정합성을 지키는게 우선이라고 생각했습니다. write-through 전략의 이론처럼 캐시저장소와 데이터베이스의 동기화시켜 데이터의 정합성을 지키는 쪽으로 구현했습니다.</p><h2 id=q-이번주차를-통해-얻은-인사이트는-무엇이었나요>Q. 이번주차를 통해 얻은 인사이트는 무엇이었나요?<a hidden class=anchor aria-hidden=true href=#q-이번주차를-통해-얻은-인사이트는-무엇이었나요>#</a></h2><blockquote><p>이번주차를 통해 얻은 인사이트와 다음에 적용할 포인트가 무엇이며,
이번학습을 통해서 성능/동시성 에 대한 어떤 관점이 생겼을까요?</p></blockquote><p>제가 얻은 인사이트는</p><ul><li>첫번째로는 분산락은 트랜잭션보다 먼저 수행되어야하며, 트랜잭션이 종료후에 락을 해제하므로 트랜잭션보다 나중에 끝난다.<ul><li>락획득 -> 트랜잭션시작 -> 수행 -> 트랜잭션종료 -> 락해제</li></ul></li><li>분산락은 방어선 역할일뿐, 기존의 RDBMS의 비관적락과 논리락인 낙관적락 등의 대체제는 아니다.</li><li>캐싱에는 읽기 전략만 있는게 아니라 쓰기전략도 존재하며, 쓰기전략에는</li></ul><blockquote><p>앞으로 실무프로젝트나 이후 과제에서 &ldquo;이 전략을 사용해보고싶다&rdquo; 포인트가 있을까요?</p></blockquote><ul><li><p>기존의 락으로 해결하기 어렵고, 분산락만이 해결될 수 있는 상황은 어떤 상황인지에 대해 나만의 언어로 정리해보고 싶습니다.</p></li><li><p>프로젝트라기보다는 이 주제에 대해서 조금더 부딪혀보고 조금이라도 더 이해해보고 싶다는 생각이 들었습니다.</p></li><li><p>왜 락획득을 트랜잭션접근 이전에 해야될까? 이 순서가 지켜지지 않을때 왜 데이터의 정합성이 깨져버릴까? 에 대한 구체적인 예시를 근거로 만들어내서 나만의 언어로 정리해보고싶습니다.</p></li><li><p>이번주차에 연관된 기술이론을 바탕으로 주먹구구식으로 과제에 접목해서 임해왔지만, 성능적인 측면을 개선해보는 조금 더 나아가서 생각해보고 깊게 고민해보고 싶습니다.</p></li><li><p>캐싱전략들중 여러개의 전략들이 있는데 직접 구현해보고 그 차이점이 무엇인지 나만의 언어로 정리해보고싶습니다.</p></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://loveAlakazam.github.io/blog/docs/rdbms-locks/><span class=title>Next »</span><br><span>RDBMS 락을 사용한 동시성문제 해결</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://loveAlakazam.github.io/blog/>EK Dev Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>