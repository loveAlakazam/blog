---
title: "RDBMS 락을 사용한 동시성문제 해결"
date: "2025-04-22"
draft: false
---

## 동시성 문제 (RaceCondition)

여러개의 스레드가 같은 공유자원에 대해서 동시에 읽기/쓰기 접근 요청할 때
공유자원의 데이터의 정합성이 깨지는 현상.

---

## 데드락 (DeadLock)

```md
화장품가게 에는 립밤 1개, 스킨로션 1개 를 판매하고 있다.

- 손님 A가 립밤 1개를 집었다.
- 손님 B가 스킨로션 1개를 집었다.
```

손님 A 는 (B가 집은) 스킨로션을 원하고, 손님 B 는 (A가 집은) 립밤을 원한다.

손님 A의 입장에서는 손님B가 스킨로션을 내려놓을 때까지 기다려야하고
손님 B의 입장에서는 손님A가 립밤을 내려놓을 때까지 기다려야한다.

즉 둘중한명이 내려놓기까지 아무것도 못하고 무한정 기다려야한다. 이것이 데드락이다.

아무것도 못하는 상태고 기다리는 상태가 Blocking 이다.
여기까지만해도 우리가 알고있는 데드락이다.

이 데드락은, 상호배제(Mutual Exclusion) 의 문제점이기도하다.
상호배제란 공유자원을 먼저 사용하게되면 다른 스레드의 접근을 막기 위해 락(Lock)을 걸어놓는다.
사용을 끝내면 락을 해제하는 식이다.

데이터베이스에서도 동시성이 깨지는 현상이 있지만 데이터베이스에서도 락이 존재하지만 멀티스레드의 관점과는 약간의 차이가 있다.

---

## 데이터베이스 락

데이터베이스는 Lock의 유효범위(임계구역)를 고려해야하며
트랜잭션 범위 내에서 락이 획득되면 트랜잭션이 종료될 때까지 락을 해제한다.

- 1. 트랜잭션의 락의 시작과 끝이 길 때

```shell
Transaction {
    Lock();
    .
    .
    .
    .
    .
    .
    UnLock()
}
```

- 2. 트랜잭션의 락의 시작과 끝이 짧을때

```shell
Transaction {
    .
    .
    Lock();
    .
    UnLock()
    .
    .
    .
}
```

락의 유효범위가 좁으면 금방 실행할 수 있지만, 유효범위가 넓으면 실행하는데 시간이 걸린다.

커밋의 작업단위가 길어진다면 어떻게 될까? 다른 트랜잭션은 끝날때까지 기다려야한다. 그러므로 다른 트랜잭션의 병목현상을 막기위해서는 트랜잭션의 범위를 좁히는게 좋다.

---

## 낙관적락 과 비관적 락

> 우리는 '짝', '나는솔로' 와 같은 방송 예능에서도 낙관적락과 비관적 락을 비유할 수 있다.
> 남자A 와 남자B 는 여자C 에게 호감이 있고 데이트를 신청했다.
>
> 여자C 는 남자A 와 데이트를 수락했다.
>
> 이 상황에 대한 남자B의 태도에 따라 낙관적락 과 비관적 락이 결정된다.

### 낙관적락 (Optimistic Lock)

> 낙관적락의 남자B 는 이 결과를 받아들이고 아예 빠른 포기를 하거나
>
> 몇번 재시도를 해보지만 여자 C의 마음을 얻지 못하면 그냥 포기한다.

실생활과 연관지어도 아직 이게 왜 낙관적락과 무슨상관이냐고 할 수 도 있겠다.
쿼리문 실습예제를 통해서 왜 낙관적락은 빠른포기를 하는 남자인지를 증명 해보겠다.

![optimistic-lock](../images/optimistic-lock.png)

- 낙관적락은 논리적인 락이다. 실제로 데이터베이스의 락과 다르다.
- 데이터에 버젼이 있는데 조회를 할때는 Version이 변하지 않는다.
  반면 업데이트할 때는 Version을 확인한다. Version이 다르면 업데이트 버젼이 다르므로 충돌이 된거다. version이 다르다면 이미 다른 트랜잭션에서 업데이트를 한것이라고 볼 수있다.
  충돌이 발생하면 실패된 트랜잭션은 롤백처리된다. 이후에 다시 재시도를 할 기회를 주거나 빠른 예외를 리스폰스하면된다.

### 비관적락 (Pessimistic Lock)

> 비관적락의 남자B 는 이 절대 포기하지 않고 여자 C를 원한다.
>
> 즉 여자C 가 다가올 때까지 계속 우직하게 기다린다.

이론적인 개념을 먼저 정리를 해보자면, 비관적락은 데이터베이스 수준의 물리적인 락이다.
물리적락은 대표적으로 `X-Lock` 과 `S-Lock` 이 있다.

먼저 두개의 락의 공통점이 있다. **락을 얻지 못한 다른 트랜잭션들은 UPDATE 를 할 수 없다.**

- X-Lock

  > 실생활 예시로는 "사생활 보호필름"이다. 사생활 보호필름은 옆에있는 다른사람이 내 폰화면의 내용을 볼 수 없다. (만지는건 당연히 안된다.)

  - X-Lock은 다른트랜잭션은 데이터로우에 읽기/쓰기 수행을 할 수 없다. 락을 얻은 트랜잭션은 데이터로우에 대한 읽기/쓰기 수행을 할 수있다.

- S-Lock

  > 실생활 예시로는 "보호필름" 이다. 그냥 휴대폰 보호필름은 옆에있는 다른 사람이 내 폰화면의 내용을 볼 수 있다. (만지는건.. 범죄다..)

  - S-Lock은 다른트랜잭션은 데이터로우에 읽기 가 가능하며, 여러개의 트랜잭션이 동일한 Row에 대해 S-Lock을 따로 소유한다.

이 물리적인락이 성공할때까지 무한정 기다린다. 만일 데이터가 많아져서 수많은 데이터가 기다려야된다면 무한정 기다리다가 TimeOut 이 발생할 수 있다.

그런데 이론 내용만으로는 왜 무한정으로 기다리는지 납득이 안된다. 그래서 콘서트예약서비스의 예를 들어서 해보자.

---

- [콘서트 서비스에서 적용한 낙관적락과 비관적락](https://github.com/loveAlakazam/hh-08-concert/wiki/07_RDBMS_%EB%9D%BD%EC%9D%84%ED%99%9C%EC%9A%A9%ED%95%9C_%EB%8F%99%EC%8B%9C%EC%84%B1%EC%A0%9C%EC%96%B4%EB%B3%B4%EA%B3%A0%EC%84%9C)

---

## 회고

나는 낙관적락과 S-Lock을 동일하게 본 정말 바보같은 생각을 했었다. 엄연히 다른 개념인데 너무 대충 블로그글들을 발췌해서 복붙하는 형식으로 공부를 해온 내 모습을 반성했다.
